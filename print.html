<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Neotron - The Embedded Rust Home Computer Platform</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> What is Neotron?</a></li><li class="chapter-item expanded "><a href="licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="credits.html"><strong aria-hidden="true">3.</strong> Credits</a></li><li class="chapter-item expanded affix "><li class="part-title">The Software</li><li class="chapter-item expanded "><a href="bios.html"><strong aria-hidden="true">4.</strong> The Neotron BIOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bios_apicalls.html"><strong aria-hidden="true">4.1.</strong> API Calls</a></li></ol></li><li class="chapter-item expanded "><a href="os.html"><strong aria-hidden="true">5.</strong> The Neotron OS</a></li><li class="chapter-item expanded "><a href="command_shell.html"><strong aria-hidden="true">6.</strong> The Neotron Command Shell</a></li><li class="chapter-item expanded "><a href="menu_shell.html"><strong aria-hidden="true">7.</strong> The Neotron Command Menu</a></li><li class="chapter-item expanded "><a href="applications.html"><strong aria-hidden="true">8.</strong> Neotron Applications</a></li><li class="chapter-item expanded affix "><li class="part-title">The Hardware</li><li class="chapter-item expanded "><a href="hardware.html"><strong aria-hidden="true">9.</strong> Common Hardware</a></li><li class="chapter-item expanded "><a href="neotron_32.html"><strong aria-hidden="true">10.</strong> Neotron 32</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="neotron_32_video.html"><strong aria-hidden="true">10.1.</strong> Video</a></li><li class="chapter-item expanded "><a href="neotron_32_audio.html"><strong aria-hidden="true">10.2.</strong> Audio</a></li><li class="chapter-item expanded "><a href="neotron_32_sdmmc.html"><strong aria-hidden="true">10.3.</strong> SD/MMC</a></li><li class="chapter-item expanded "><a href="neotron_32_ps2.html"><strong aria-hidden="true">10.4.</strong> PS/2 and Joystick</a></li><li class="chapter-item expanded "><a href="neotron_32_wifi.html"><strong aria-hidden="true">10.5.</strong> WiFi</a></li><li class="chapter-item expanded "><a href="neotron_32_expansion.html"><strong aria-hidden="true">10.6.</strong> Expansion</a></li><li class="chapter-item expanded "><a href="neotron_32_parallel.html"><strong aria-hidden="true">10.7.</strong> Parallel Port</a></li><li class="chapter-item expanded "><a href="neotron_32_rs232.html"><strong aria-hidden="true">10.8.</strong> RS-232</a></li><li class="chapter-item expanded "><a href="neotron_32_midi.html"><strong aria-hidden="true">10.9.</strong> MIDI</a></li><li class="chapter-item expanded "><a href="neotron_32_usb.html"><strong aria-hidden="true">10.10.</strong> USB</a></li><li class="chapter-item expanded "><a href="neotron_32_rtc.html"><strong aria-hidden="true">10.11.</strong> RTC</a></li></ol></li><li class="chapter-item expanded "><a href="neotron_340st.html"><strong aria-hidden="true">11.</strong> Neotron 340ST</a></li><li class="chapter-item expanded "><a href="neotron_500.html"><strong aria-hidden="true">12.</strong> Neotron 500</a></li><li class="chapter-item expanded "><a href="neotron_600.html"><strong aria-hidden="true">13.</strong> Neotron 600</a></li><li class="chapter-item expanded "><a href="neotron_1000.html"><strong aria-hidden="true">14.</strong> Neotron 1000</a></li><li class="chapter-item expanded "><a href="neotron_9x.html"><strong aria-hidden="true">15.</strong> Neotron 9X</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Neotron - The Embedded Rust Home Computer Platform</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-neotron" id="what-is-neotron">What is Neotron?</a></h1>
<p>Neotron is an attempt to make computers simple again, whilst also taking advantage of the very latest in programming language development. We are saddened by chat clients that require multi-Gigabyte installs, and systems with hundreds of millions of lines of source code that no one person could ever hope to understand. We want to build a machine that is sized for an individual to comprehend, not a trillion-dollar corporation.</p>
<p>If you want a pithy sound-bite, it's like CP/M for tiny ARM microcontrollers, but written in Rust.</p>
<h2><a class="header" href="#tell-me-more" id="tell-me-more">Tell me more...</a></h2>
<p>Neotron is based around four fundamental components.</p>
<ul>
<li>A standardised OS interface, for portable Applications to call. This provides APIs for reading/writing files, accessing devices, writing to the screen, playing audio, etc.</li>
<li>A standardised BIOS interface, for the Operating System to call. The BIOS abstracts the specific hardware implementation of the Video, Audio, UART, SPI, I2C, GPIO, Disk Drive, Parallel Printer, Keyboard and Mouse interfaces. By using the BIOS, we should be able to run the <em>exact same</em> Neotron OS on a variety of different microcontrollers.</li>
<li>Use of the Rust Programming Language to write as much of the software as possible (we avoid raw assembler as much as possible, but we're happy to port existing applications that are written in C even if we avoid that language in the system software).</li>
<li>The ARM Thumb-v7M instruction set (as supported by ARM Cortex-M based microcontrollers from the M3 and up). This is what allow us to run the same programs on microcontrollers from different vendors.</li>
</ul>
<p>Looking back at classic home computers of the 1980s and early 1990s though, we see systems that were (and still are) simple enough to understand, or even - with time - to learn to master. Here's a rough comparison with just a few of the classic systems we have taken as inspiration:</p>
<table><thead><tr><th align="left">Feature</th><th align="left">Neotron 32</th><th align="left">Neotron 340ST</th><th align="left">IBM PC 5150</th><th align="left">BBC Micro Model-B</th><th align="left">Commodore 64</th><th align="left">Macintosh 128K</th><th align="left">Amstrad PCW8256</th><th align="left">Amiga 1000</th><th align="left">Acorn Archimedes A305</th></tr></thead><tbody>
<tr><td align="left">Launch Year</td><td align="left">2020</td><td align="left">2020</td><td align="left">1981</td><td align="left">1981</td><td align="left">1982</td><td align="left">1984</td><td align="left">1985</td><td align="left">1985</td><td align="left">1987</td></tr>
<tr><td align="left">Instruction Set</td><td align="left">ARMv7E-M</td><td align="left">ARMv7E-M</td><td align="left">Intel x86</td><td align="left">MOS 6502</td><td align="left">MOS 6502</td><td align="left">Motorola 68k</td><td align="left">Zilog Z80</td><td align="left">Motorola 68k</td><td align="left">ARM v2</td></tr>
<tr><td align="left">CPU</td><td align="left">Cortex-M4</td><td align="left">Cortex-M7</td><td align="left">8088</td><td align="left">6502A</td><td align="left">6510</td><td align="left">68000</td><td align="left">Z80A</td><td align="left">68000</td><td align="left">ARM2</td></tr>
<tr><td align="left">Clock Speed</td><td align="left">80 MHz</td><td align="left">216 MHz</td><td align="left">4.77 MHz</td><td align="left">2 MHz</td><td align="left">1 MHz</td><td align="left">8 MHz</td><td align="left">4 MHz</td><td align="left">8 MHz</td><td align="left">8 MHz</td></tr>
<tr><td align="left">Low Level OS</td><td align="left">Neotron BIOS</td><td align="left">Neotron BIOS</td><td align="left">IBM BIOS</td><td align="left">Acorn MOS</td><td align="left">KERNAL</td><td align="left">Toolbox</td><td align="left">XBIOS</td><td align="left">Kickstart</td><td align="left">RISC OS</td></tr>
<tr><td align="left">High Level OS</td><td align="left">Neotron OS</td><td align="left">Neotron OS</td><td align="left">PC-DOS 1.0</td><td align="left">Acorn MOS</td><td align="left">N/A</td><td align="left">System</td><td align="left">CP/M Plus</td><td align="left">AmigaDOS</td><td align="left">RISC OS</td></tr>
<tr><td align="left">Shell</td><td align="left">Neotron Shell</td><td align="left">Neotron Shell</td><td align="left">COMMAND.COM</td><td align="left">BBC BASIC</td><td align="left">BASIC v2</td><td align="left">Finder</td><td align="left">CP/M CCP</td><td align="left">Workbench</td><td align="left">RISC OS Desktop</td></tr>
<tr><td align="left">Primary Language</td><td align="left">Rust</td><td align="left">Rust</td><td align="left">Assembly / C</td><td align="left">Assembly</td><td align="left">Assembly</td><td align="left">Object Pascal</td><td align="left">Assembly</td><td align="left">BCPL / C</td><td align="left">Assembly / BBC BASIC</td></tr>
<tr><td align="left">ROM</td><td align="left">256K</td><td align="left">1024K</td><td align="left">8K</td><td align="left">32K</td><td align="left">16K</td><td align="left">64K</td><td align="left">256 bytes</td><td align="left">256K</td><td align="left">512K</td></tr>
<tr><td align="left">RAM</td><td align="left">32K</td><td align="left">8512K*</td><td align="left">16K to 256K</td><td align="left">32K</td><td align="left">64K</td><td align="left">128K</td><td align="left">64K</td><td align="left">256K</td><td align="left">512K</td></tr>
<tr><td align="left">Self-hosting</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr>
</tbody></table>
<p>* Made up of 320K of internal SRAM and 8192K of external SDRAM</p>
<p>The <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">IBM PC</a> BIOS was stored in a ROM chip on the motherboard. It provided a certain level of hardware abstraction, with APIs for writing to the screen, setting the video mode and reading/writing from block devices such as floppy drives. The BIOS initialised the hardware, loaded the first sector of a chosen block device into RAM and then executed the code contained within. This was the Boot Sector and contained enough code to load the rest of the Operating System. PC-DOS made use of BIOS APIs, but often games would bypass both MS-DOS and the BIOS and access hardware directly. Famously, Microsoft was able to sell copies of PC-DOS (relabelled as MS-DOS) to manufacturers of 'PC compatibles', provided they had a BIOS ROM which offered the same (reverse-engineered) API as the IBM BIOS.</p>
<p>The <a href="https://en.wikipedia.org/wiki/BBC_Micro">BBC Micro</a> had a very advanced Operating System for the time, known as the Acorn Machine Operating System (MOS). You could add extra ROMs to the system, such as the Disk Filing System (DFS). BBC BASIC was also very advanced for the time, including a built-in 6502 assembler.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Commodore_64">Commodore 64</a> contained two 8 KiB ROM chips - one contained the OS (called the KERNAL) and one contained a rebadged Microsoft 6502 BASIC. The KERNAL was very low level and Microsoft BASIC didn't include any commands to produce graphics or sound - developers were expected to interact with memory mapped hardware directly. The C64 KERNAL could be assembled using PET RESIDENT ASSEMBLER on a Commodore PET, but the <a href="https://www.pagetable.com/?p=774">Microsoft BASIC source code</a> was written on a PDP-10 using the MACRO-10 assembler.</p>
<p>The original <a href="https://en.wikipedia.org/wiki/Macintosh_128K">Apple Macintosh</a> had a ROM on the motherboard which initialised the hardware and drew a graphical image on the screen indicating that the user should insert the System disk. The ROM then loaded the OS (known as <em>System</em> up to version 7, and <em>Mac OS</em> for versions 8 and 9) into RAM, along with a graphical desktop called Finder. Applications on the Macintosh (including the Finder) made use of a number of graphical routines stored in the ROM, known as the <em>Macintosh Toolbox</em>.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Amstrad_PCW">Amstrad PCW8256</a> was similar to the Amiga 1000 in that the main BIOS was loaded from floppy disk. Going further than the Amiga though, the PCW didn't include a ROM chip at all. Instead the 256 bytes of bootstrap code were loaded from the microcontroller responsible for managing the printer interface. The bootstrap loaded the so-called <em>XBIOS</em> from floppy disk into RAM. XBIOS then initialised the hardware and loaded CP/M Plus (also known as CP/M 3.0). The shell was the familiar CP/M Command Console Processor (CCP), and both the OS and the CCP were the same across a wide range of CP/M machines from many different vendors, with the BIOS providing the hardware abstraction layer.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Amiga_1000">Amiga 1000</a> hardware didn't include much in the way of a ROM at all. A basic bootstrap program stored in ROM was able to load most of the low-level OS (known as <em>Kickstart</em>) into a special write-only area of RAM. Kickstart could then load either the particular game being played, or AmigaDOS and a graphical shell known as Workbench. On later machines (such as the A500), the Kickstart was stored in ROM.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Acorn_Archimedes">Acorn Archimedes</a> was first shipped with an OS in ROM called Arthur, but this was soon replaced with the more familiar RISC OS 2 (and later RISC OS 3). The entire OS - bootstrap, HAL, filesystem and GUI - was one on ROM chip, meaning it booted up very quickly, without needing to read from any sort of disc.</p>
<p>The key feature for many these systems (apart from the Commodore 64), was portability across other machines in the family (or, indeed, third-party clones). The PC, the Amiga, the Macintosh and CP/M all provided a <em>platform</em>, and if you respected certain limits when writing your software, that software was then portable across all the systems which provided that platform. For Neotron, this is a key concept - because microcontrollers vary so wildly, we have a BIOS that implements hardware abstraction, just like with the PC or CP/M machines. We then run a standard OS (indeed, the same OS image should work on every Neotron machine - more-or-less), either from ROM or loaded into RAM by the BIOS. On top of the OS is the text-mode Neotron Shell (like CP/M's CCP, or MS-DOS's COMMAND.COM). Booting to a graphical desktop would be nice, but given the Neotron 32 only has 32 KiB of RAM (barely enough for a low resolution frame-buffer), text mode is the default. Ultimately, a Neotron 32 should be able to 'compete' on a functional level with an un-expanded IBM PC 5150 or a BBC Microcomputer Model-B. The Neotron 340ST meanwhile, should be more like a Macintosh, Archimedes or Amiga in terms of functionality and in time we do hope to develop a GUI for this system.</p>
<p>As with the CP/M and MS-DOS machines, we hope that in the future there will be a wide range of machines in the Neotron family. These Neotron systems won't generally aim to be super cheap, although we will tend to target commodity microcontrollers that only cost circa $10 or less, so they shouldn't be outrageously expensive. They will, however, aim to be usable computers that can do interesting things, while being simple enough to understand in their entirety and open enough to allow you to gain that understanding.</p>
<h2><a class="header" href="#what-can-i-do-with-it" id="what-can-i-do-with-it">What can I do with it?</a></h2>
<p>You can do what you can do with most 1980s home computers:</p>
<ul>
<li>Type things on the keyboard.</li>
<li>Use a joystick or a mouse.</li>
<li>Manage files on internal or removable storage.</li>
<li>Load programs from internal or removable storage.</li>
<li>Type in your own programs.</li>
<li>Put text and graphics on the screen.</li>
<li>Make various beepy noises.</li>
<li>Connect various internal expansion cards or external peripherals.</li>
<li>Expand the system in ways the designer couldn't imagine.</li>
</ul>
<p>But most importantly, you can learn the fundamentals of what it takes for a computer to be a <em>computer</em>. And you can study the source code and hardware schematics required to make that happen. You can even take the designs and go off and produce your own version - maybe to add a specific interface for a particular peripheral that interests you - all with no licence fees to pay.</p>
<h2><a class="header" href="#what-cant-i-do-with-it" id="what-cant-i-do-with-it">What can't I do with it?</a></h2>
<p>A Neotron system will probably never:</p>
<ul>
<li>Support multiple processes (although Windows 3.1-style co-operative task switching is plausible).</li>
<li>Support 3D graphics (e.g. OpenGL).</li>
<li>Support virtual addressing (i.e. make use of an MMU).</li>
<li>Be POSIX compatible.</li>
<li>Have a huge software library (or probably any real library of software).</li>
<li>Run existing MS-DOS, Windows or Linux programs.</li>
<li>Be able to run <code>rustc</code>.</li>
<li>Have a port of Rust's <code>libstd</code>.</li>
<li>Be directly targetable from Rust with <code>--target=thumbv7em-unknown-neotron-eabi</code>.</li>
<li>Be useful for day to day use.</li>
<li>Be finished.</li>
</ul>
<p>If you want a decent open-source UNIX Operating System, have a look at FreeBSD (or NetBSD, or OpenBSD). If you want a small teaching-oriented open-source UNIX Operating System, look at XV6, or maybe MINIX 3. If you want to learn about Linux, try Linux from Scratch. If you want to learn an ancient Arm based Operating System which still has a flavour of the original BBC Microcomputer, look at RISC OS (it's open source now). If you want a proper OS written in Rust, look at Redox. And if you want to do any of that on a system you don't have, try qemu, or rpcemu.</p>
<h2><a class="header" href="#is-this-a-good-idea" id="is-this-a-good-idea">Is this a good idea?</a></h2>
<p>It's certainly not a profitable idea. It's not even likely to be an efficient use of our time and resources. But it is proving to be a fun and educational project to work on, and we hope others find it useful and/or enjoyable too.</p>
<h2><a class="header" href="#but-what-about-existing_product" id="but-what-about-existing_product">But what about ${EXISTING_PRODUCT}?</a></h2>
<h3><a class="header" href="#raspberry-pi" id="raspberry-pi">Raspberry Pi</a></h3>
<p>Yes, you can buy a Raspberry Pi for a little as $5 - and it's a wonderful product that has done arguably more than anything since the BBC Microcomputer in terms of putting hardware you can actually program into the hands of young people. But, the downside is that you get a big, complicated piece of silicon, a proprietary GPU subsystem, 25 million lines of kernel source code, and even more in a user-land which has parts dating back over 30 years. No one person could hope to understand all of that! While we could probably port the Neotron OS to the Raspberry Pi, we'd have to treat the video sub-system as a black-box (like RISC OS does) and the complexity and lack of documentation of that subsystem presents a big barrier to fully understanding the system. Not to mention the the fact that only partial schematics are available, there are no PCB designs available, and there's no general availability on the main processor. It does what it needs to do for its target market quite admirably - but it's not a Neotron.</p>
<h3><a class="header" href="#x86-based-systems-like-the-original-ibm-pc" id="x86-based-systems-like-the-original-ibm-pc">x86 based systems, like the original IBM PC</a></h3>
<p>You could build yourself a clone of the original IBM PC (<a href="https://monotech.fwscart.com/">kits do exist</a>), but it involves a lot of components that are very difficult to obtain nearly 40 years since that design first came out. Rust is also designed around a flat memory model (rather than the segmentation:offset model used by the 16-bit 8086), and that means using at least a 32-bit <a href="https://hackaday.com/2015/11/17/a-modern-386-development-board/">Intel 80386</a>. And, of course, these are plain CPUs rather than microcontrollers, so you'll need to find a 'chipset' containing interrupt controller, DRAM memory controller and timers; as well as separate video, sound and IO sub-systems. Our System-on-Chip based design simplifies the motherboard design and reduces cost, and unlike with modern x86 SoCs, we don't have to deal with complicated legacy subsystems such as UEFI, ACPI or PCI.</p>
<h3><a class="header" href="#6502-based-systems-like-the-pe6502-and-commander-x16" id="6502-based-systems-like-the-pe6502-and-commander-x16">6502 based systems (like the PE6502 and Commander X16)</a></h3>
<p>You could build a 6502 based system, and many people do, but the Rust programming language doesn't (and probably never will) support an 8-bit CPU with only 256 bytes of stack.</p>
<h3><a class="header" href="#68000-based-systems" id="68000-based-systems">68000 based systems</a></h3>
<p>At the present time, there is no 68k backend in LLVM. If there was, a 68000 system would certainly make an interesting alternative to Neotron.</p>
<h3><a class="header" href="#powerpc-based-systems" id="powerpc-based-systems">PowerPC based systems</a></h3>
<p>LLVM does have a PowerPC backend, but unfortunately most PowerPC based chips only come in monster 380+ pin BGA packages, with multiple power rails. This unfortunately puts them beyond the scope of a simple hobby project, much as the author would love to build a machine that harks back to the IBM RS/6000 and PowerMacintosh machines of the 1990s.</p>
<h3><a class="header" href="#risc-v-based-systems" id="risc-v-based-systems">RISC-V based systems</a></h3>
<p>There is an increasing number of RISC-V based microcontrollers with very small SRAMs, matched by an increasing number of multi-core 64-bit SoCs designed to run Linux from a huge bank of DDR3. At the current time, however, there isn't much in the middle.</p>
<p>A Neotron system built around an open-source RISC-V code run from an FPGA would be an interesting way to increase the openness of the system and remains a future possibility.</p>
<h3><a class="header" href="#sparc-based-systems" id="sparc-based-systems">SPARC based systems</a></h3>
<p>The Gaisler LEON3 is available in VHDL form under the GPL, along with a number of other components required to make a full SoC. The LEON3 implements the SPARC V8 ISA, support for which is available in the Rust compiler. However, this would require an FPGA based system and it's unknown whether the full GRLIB SoC would fit into any of the FPGAs supported by the various open-source FPGA synthesis tools (such as the Lattice iCE40).</p>
<h3><a class="header" href="#atmel-avr-based-systems" id="atmel-avr-based-systems">Atmel AVR based systems</a></h3>
<p>Many people have built Atmel AVR based systems, but those CPUs are fairly limited in terms of performance and tend to need to be programmed in raw assembler. There is a Rust AVR port, but it's only in alpha state at the moment.</p>
<h2><a class="header" href="#what-is-this-book" id="what-is-this-book">What is this book?</a></h2>
<p>This book describes the Neotron system - from the hardware schematics, all the way up to how to write applications for the system. It is intended to be the canonical reference, although where the source code differs from what is described in this book, we reserve the right to be pragmatic and change either to match the other (or leave them in disagreement...). This book also represents our latest thoughts on a particular topic, and the source code may lag behind while we get around to the implementation. We endeavour to note where this is the case.</p>
<h2><a class="header" href="#versioning" id="versioning">Versioning</a></h2>
<p>Each component has a semantic version number - <code>major.minor.patch</code>. The assocation is:</p>
<ul>
<li>The BIOS will require a compatible hardware version.</li>
<li>The OS will require a compatible BIOS version.</li>
<li>The Shell and Applications will require a compatible OS version.</li>
</ul>
<h2><a class="header" href="#open-source-and-commercial-sales" id="open-source-and-commercial-sales">Open Source and Commercial Sales</a></h2>
<p>Neotron is designed to be open - the user must have free rein to inspect the source code and the schematics, and change them to suit their needs. To this end, the main BIOS and OS implementations are licensed under the <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU Public Licence v3</a> or any later version. To encourage the adoption of Rust for embedded development, most of the library crates developed for this project are licensed under both the <a href="https://opensource.org/licenses/MIT">MIT</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> licences, just like the Rust compiler itself. We do intend to sell a range of kits and pre-built PCBs, but you can (and should!) take our designs as inspiration and put your own spin on them.</p>
<p>This book is licensed under Creative Commons <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA 4.0</a>. Any source examples in this book may also be used under the <a href="https://opensource.org/licenses/MIT">MIT</a> or <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> licences.</p>
<h2><a class="header" href="#credits" id="credits">Credits</a></h2>
<p>Neotron started as a project called 'Monotron', by <a href="https://github.com/thejpster">@thejpster</a>. This was based on the work of the <a href="https://github.com/rust-embedded">Rust Embedded Working Group</a>, and inspiration from the following (in no particular order):</p>
<ul>
<li><a href="http://geoffg.net/maximite.html">Colour Maximite</a> - A modern PIC32 based single-board home computer.</li>
<li><a href="http://putnamelectronics.com/products.html">PE6502</a> - A modern 6502 based single-board home computer.</li>
<li><a href="https://gigatron.io/">Gigatron</a> - A single-board home computer, with a custom CPU built from TTL logic chips.</li>
<li><a href="http://commanderx16.com/">Commander X16</a> - A single-board home computer, with a 6502 and an FPGA based video chip.</li>
<li><a href="http://www.linusakesson.net/scene/craft/">Craft</a> - Demonstrates bit-bashing VGA from an AtMega88</li>
<li><a href="http://tinyvga.com/avr-isa-vga">AVR-ISA</a> - Demonstrates driving an ISA bus (and an ISA VGA card) driven from an AtMega128</li>
<li>The Commodore 64C - <a href="https://github.com/thejpster">@thejpster</a>'s first home computer</li>
<li>The BBC Microcomputer range (the Model B through to the Archimedes A3000) - as used in UK schools in the 1980s</li>
<li>The Amstrad range of CP/M machines, particularly the PCW9512</li>
</ul>
<p>After meeting <a href="https://github.com/IGBC">@IGBC</a> at Oxidize 2019, discussions started around a next-generation system with higher performance. This led to the Neotron 1000, and then to the whole Neotron concept.</p>
<h1><a class="header" href="#licence" id="licence">Licence</a></h1>
<p>Neotron is designed to be open - the user must have free rein to inspect the source code and the schematics, and change them to suit their needs. To this end, the main BIOS and OS implementations are licensed under the <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU Public Licence v3</a> or any later version. To encourage the adoption of Rust for embedded development, most of the library crates developed for this project are licensed under both the <a href="https://opensource.org/licenses/MIT">MIT</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> licences, just like the Rust compiler itself. We do intend to sell a range of kits and pre-built PCBs, but you can (and should!) take our designs as inspiration and put your own spin on them.</p>
<p>This book is licensed under Creative Commons <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA 4.0</a>. Any source examples in this book may also be used under the <a href="https://opensource.org/licenses/MIT">MIT</a> or <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> licences.</p>
<h1><a class="header" href="#credits-1" id="credits-1">Credits</a></h1>
<p>Neotron started as a project called 'Monotron', by <a href="https://github.com/thejpster">@thejpster</a>. This was based on the work of the <a href="https://github.com/rust-embedded">Rust Embedded Working Group</a>, and inspiration from the following (in no particular order):</p>
<ul>
<li><a href="http://geoffg.net/maximite.html">Colour Maximite</a> - A modern PIC32 based single-board home computer.</li>
<li><a href="http://putnamelectronics.com/products.html">PE6502</a> - A modern 6502 based single-board home computer.</li>
<li><a href="https://gigatron.io/">Gigatron</a> - A single-board home computer, with a custom CPU built from TTL logic chips.</li>
<li><a href="http://commanderx16.com/">Commander X16</a> - A single-board home computer, with a 6502 and an FPGA based video chip.</li>
<li><a href="http://www.linusakesson.net/scene/craft/">Craft</a> - Demonstrates bit-bashing VGA from an AtMega88</li>
<li><a href="http://tinyvga.com/avr-isa-vga">AVR-ISA</a> - Demonstrates driving an ISA bus (and an ISA VGA card) driven from an AtMega128</li>
<li>The Commodore 64C - <a href="https://github.com/thejpster">@thejpster</a>'s first home computer</li>
<li>The BBC Microcomputer range (the Model B through to the Archimedes A3000) - as used in UK schools in the 1980s</li>
<li>The Amstrad range of CP/M machines, particularly the PCW9512</li>
</ul>
<p>After meeting <a href="https://github.com/IGBC">@IGBC</a> at Oxidize 2019, discussions started around a next-generation system with higher performance. This led to the Neotron 1000, and then to the whole Neotron concept.</p>
<h1><a class="header" href="#the-neotron-bios" id="the-neotron-bios">The Neotron BIOS</a></h1>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>The Neotron BIOS is the hardware-abstraction layer for the Neotron Operating
System. It allows the OS to run on different hardware platforms with the minimum
number of changes.</p>
<pre><code>+-------+-------------+
|       |             |
| Shell | Application |
|       |             |
+-------+-------------+
|                     |
|  Operating System   |
|                     |
++===================++
||                   ||
||       BIOS        ||
||                   ||
++===================++
|                     |
|    Raw Hardware     |
|                     |
+---------------------+
</code></pre>
<h2><a class="header" href="#what-goes-in-the-bios-and-what-goes-in-the-os" id="what-goes-in-the-bios-and-what-goes-in-the-os">What goes in the BIOS and what goes in the OS?</a></h2>
<p>As a general rule, the BIOS should contain all the drivers for the main system-on-chip (SoC) in that particular Neotron system. It should also understand which pins on the SoC have been assigned to which functions. It is therefore a function of the netlist for the main PCB, and the components fitted to it.</p>
<p>If a particular function might apply to SoCs from different manufacturers, or to an expansion card that could be inserted into multiple different models of Neotron system, it is probably better placed in the Neotron OS.</p>
<h2><a class="header" href="#interfaces" id="interfaces">Interfaces</a></h2>
<p>A BIOS should offer an interface upwards to the OS so that the OS can:</p>
<ul>
<li>Discover the hardware in the system</li>
<li>Select and use various video modes:
<ul>
<li>Text modes</li>
<li>Bitmap graphics modes</li>
<li>Split modes</li>
<li>Layered Modes</li>
<li>Hooking video scan-line interrupts</li>
</ul>
</li>
<li>Read any keyboard key events</li>
<li>Access (read from, write to and/or configure) any Serial/UART interfaces</li>
<li>Access any I²C buses, and any devices attached to its bus</li>
<li>Access any SPI buses, and any devices attached to its chip selects</li>
<li>Access any USB Host Controllers, and any USB devices attached</li>
<li>Access any block devices, via whatever interface they are connected to</li>
<li>Read from / write from any audio FIFOs</li>
<li>Configure a periodic 'system tick' timer</li>
<li>Obtain / set the current calendar time</li>
<li>Measure elapsed time since boot-up (e.g. in microseconds)</li>
<li>Hook interrupts for the external IRQ lines</li>
<li>Access any OS-specific non-volatile configuration</li>
</ul>
<p>On top of these APIs sits the Neotron OS, which should be portable with almost
zero changes to any device with a Neotron BIOS. While you could write an
application which uses the BIOS directly, most applications will use the
higher-level APIs exposed by the Neotron OS.</p>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>Many Neotron sytems will have an element of user configuration to them - e.g. which cards are fitted to which expansion slots, or whether an optional item has been fitted to the PCB. To handle this, it is expected that the BIOS have some kind of configuration application, and some non-volatile storage that will hold the configuration across a power cycle. Typically this will be in the battery-backed real-time clock, but it could equally be in an EEPROM.</p>
<h2><a class="header" href="#calling-a-bios-api" id="calling-a-bios-api">Calling a BIOS API</a></h2>
<p>On ARM systems, calling a kernel API is usually done through a <code>SWI</code> or <code>SVC</code>
machine instruction. This effectively triggers an interrupt, putting the CPU
into interrupt mode where it starts executing the <code>SWI</code> exception handler.
Unfortunately, calling the <code>SWI</code> instruction and passing arguments via registers
can only be performed from assembly language, and is not supported by the
<code>cortex-m</code> crate at this time.</p>
<p>Monotron instead used a simple alternative - when the application was started by
the OS, the OS passed it a pointer to a structure of function pointers. You can
think of this as being like an old-fashioned jump table. When the application
wanted to get the OS to do something, the application just called the
appropriate function through the given pointer. The downside was that the
Monotron OS functions used the same stack as the application, and it was
impossible for an application to exit back to the OS unless it returned from
<code>main</code> (i.e. there was no <code>exit()</code> function you could call). The Neotron BIOS
accepts these downsides in the same of simplicity, and takes the Monotron
approach - at least for the BIOS-OS ABI.</p>
<p>The BIOS is responsible for starting the system and performing hardware
initialisation. It will also search for the OS, either in Flash memory, on disk, or
perhaps even loaded over a UART. The OS then has its initialisation function
called, to which the structure of BIOS function calls is passed. The
initialisation function is specified as a function pointer stored at a
specific offset (most likely the first four bytes of the OS image). To avoid
undefined behaviour, that initialisation function should memset the <code>.bss</code>
section to all-zeroes and, if necessary, initialise the <code>.data</code> section using
values stored in Flash memory.</p>
<p>Most of the BIOS APIs will be 'blocking' - that is, the function call will not
return until the BIOS has completed the operation (e.g. read the sector from
disk, or written the bytes to the UART). It is possible in the future that BIOS
APIs will be added which allows operations to be <em>asynchronous</em> - that is, to
return immediately once the operation has been <em>queued</em> and then either call
some function or set some marker value in memory once the operation has been
completed. Such an API is more complex to develop, and has interesting
challenges around ensuring the memory passed to the function remains available
(i.e. it isn't just on the stack of the calling function). However, these APIs
are generally more efficient in terms of CPU time, as the CPU does not have to
waste cycles spinning in the main thread whilst it waits for the operation to
complete - for example, you could be writing some sectors to disk and performing
an I²C read from the HID controller asynchronously, whilst also calculating new
display graphics and audio in the main thread.</p>
<p>For now however, the blocking APIs were sufficient for MS-DOS, and they will be sufficient here.</p>
<h2><a class="header" href="#why-split-the-os-and-the-bios" id="why-split-the-os-and-the-bios">Why split the OS and the BIOS?</a></h2>
<p>We could take the Linux / Windows NT approach, with a boot-loader that performs
the bare minimum required to get the kernel (or, in our case, what we call the
'OS') into RAM and start it running. The boot-loader for a PC is usually a UEFI
BIOS but on an older system might be an IBM PC-compatible 'legacy' BIOS. The
operations performed typically include DRAM setup, rudimentary console setup
(either frame-buffer or over UART) and accessing the kernel from some kind of
block device or non-volatile memory (e.g. SD Card). The kernel then replaces
the boot-loader, which is never used again.</p>
<p>Because our Neotron systems generally have Flash memory, we don't actually
need a boot-loader in that sense. Instead, we implement something more like
the interface provided by an IBM PC-compatible 'legacy' BIOS for running
MS-DOS, which itself was modeled on the design of CP/M's BIOS and BDOS
components. In that case, the BIOS provides a fixed application binary
interface (ABI) which is unchanging. This allowed development of MS-DOS (and
CP/M) to be performed against a fixed target (or rather, multiple
implementations of a fixed ABI), allowing the same copy of MS-DOS or CP/M to
run on a variety of PCs from a variety of manufacturers. The alternative would
be to require all of the drivers and board support packages to be added into
OS kernel (as usually happens with Linux), or for the drivers to be loaded
from disk at boot-up (as with Windows). We have seen with Linux that, for
whatever reason, not all boards and peripherals get their driver support
upstreamed, and because Linux does not maintain a binary ABI for drivers,
anything that isn't upstream quickly becomes obsolete. As a case in point, try
to update the version of Linux used on circa-2015 Android tablet - you'll
quickly find yourself stuck on an old Kernel version with bespoke patches (or
worse, binary blobs) that weren't upstreamed or open-sourced. Whilst Windows
maintains a binary ABI for drivers, they are usually closed-source and of
varying quality, leading to system instabilities that are almost impossible to
debug.</p>
<p>The Neotron approach allows for:</p>
<ul>
<li>Less centralised development: the Neotron developers do not need to look
after (or even know about) your BIOS implementation, as long as it meets the
ABI</li>
<li>Easier upgrades: any system with a Neotron BIOS should be updateable to a
newer version of the Neotron OS</li>
<li>A smaller OS: the amount of code in the OS (e.g. for drivers) is reduced, which
means the OS is easier to understand and review</li>
<li>Simpler builds: everyone can run basically the same build of the OS (subject
to some constraints about the specific Arm architecture being targeted) as
everything board specific is in the BIOS</li>
<li>Better portability: because anything CPU specific is in the BIOS, it should
<ul>
<li>in theory - be possible to port the Neotron OS to another CPU architecture
with just a re-compile.</li>
</ul>
</li>
</ul>
<p>The downsides are:</p>
<ul>
<li>It's slower: there can be no optimisation across the OS / BIOS boundary.</li>
<li>Limited support: it's harder to add new classes of peripheral bus (e.g. if
we ever wanted to add support for I3C), as the old BIOSes won't know about
them.</li>
<li>Harder to design: a binary-stable ABI is harder to design in Rust than a
plain function-call API, as you have to use <code>extern &quot;C&quot;</code> and <code>#[repr(C)]</code>,
and therefore can't use significant portions of the Core Library in your API
definition.</li>
</ul>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>For BIOS testing, there will be a special 'cut-down' version of the OS which
offers only a very basic console, and direct access to all the BIOS APIs via
that console.</p>
<h2><a class="header" href="#character-sets" id="character-sets">Character Sets</a></h2>
<p>The video display engines on a Neotron system only support monospaced 8-bit
fonts (that is, fonts with only 256 glyphs and where each glyph occupies the
same horizontal space on screen), and so the mapped text buffer memory works
exclusively in the character set defined by the font. The rest of the BIOS API
works exclusively in UTF-8 encoded text, and mapping functions are provided by
the BIOS to convert from a Unicode codepoint to the font-specific character set.
Generally the first 128 glyphs will match basic ASCII (and hence the first 128
Unicode code points) for performance reasons, although that isn't necessarily
required.</p>
<p>It is possible that Neotron could be adapted to support multi-byte character
sets (e.g. for Chinese, Japanese or Korean text display where more than 256
glyphs are required), but there is no support for that planned at this time.</p>
<h1><a class="header" href="#the-neotron-bios---api-calls" id="the-neotron-bios---api-calls">The Neotron BIOS - API Calls</a></h1>
<p>Note that these systems calls are listed here for documentation and discussion
purposes. The canonical reference is the BIOS source code. Note also that these
API must be <code>extern &quot;C&quot;</code>, which means we can't use references, str-slices,
<code>Option</code> or <code>Result</code>. Instead we provide our own <code>extern &quot;C&quot;</code> alternatives.</p>
<h2><a class="header" href="#timeouts" id="timeouts">Timeouts</a></h2>
<p>Some functions accept a timeout argument. If this argument is <code>None</code>, then the
function blocks. Otherwise the function waits for up to the period specified, or
the operation is complete, whichever occurs first.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Timeout(...);

impl Timeout {
	fn frames(frames: u16) -&gt; Timeout;
	fn milliseconds(ms: u16) -&gt; Timeout;
	fn microseconds(us: u16) -&gt; Timeout;
}
<span class="boring">}
</span></code></pre></pre>
<p>All video modes on Neotron are 60 Hz and so 1 frame is approximately 16.667ms.</p>
<h2><a class="header" href="#metadata-and-versioning" id="metadata-and-versioning">Metadata and Versioning</a></h2>
<h3><a class="header" href="#api_version_get" id="api_version_get">api_version_get</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SemanticVersion(...);

fn api_version_get() -&gt; SemanticVersion;
<span class="boring">}
</span></code></pre></pre>
<p>Gets the version number of the BIOS API. You need this value to determine which
of the following API calls are valid in this particular version.</p>
<h3><a class="header" href="#bios_info_get" id="bios_info_get">bios_info_get</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bios_info_get() -&gt; ApiStrRef;
<span class="boring">}
</span></code></pre></pre>
<p>Returns a pointer to a static string slice. This string contains the version
number and build string of this particular BIOS.</p>
<h2><a class="header" href="#system-functions" id="system-functions">System Functions</a></h2>
<h3><a class="header" href="#system_memory_info_get" id="system_memory_info_get">system_memory_info_get</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SystemMemoryType {
	/// An on-chip memory optimised for code
	InstructionTightlyCoupled,
	/// An on-chip memory optimised for data
	DataTightlyCoupled,
	/// An on-chip Static RAM that can be used for code or data
	InternalStatic,
	/// An on-chip Dynamic RAM that can be used for code or data
	InternalDynamic,
	/// An off-chip Static RAM that can be used for code or data
	ExternalStatic,
	/// An off-chip Dynamic RAM that can be used for code or data
	ExternalDynamic,
}

struct SystemMemoryInfo {
	/// A human-readable label for this region
	name: ApiStrRef,
	/// The first address in the region (e.g. 0x0000)
	start_addr: usize,
	/// The length of the region
	length: usize,
	/// The memory type
	memory_type: SystemMemoryType,
}

fn system_memory_info_get(index: u8) -&gt; Option&lt;SystemMemoryInfo&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Gets information about the regions of memory in the system. An OS can use this
to work out where it can store the heap, and load any applications to. Regions
should be ordered according to their relative performance, with the fastest
region listed first. The fastest regions will be used for the most commonly used
data structures (e.g. the system stack). Regions labelled as
<code>InstructionTightlyCoupled</code> will ony be used for code (e.g code loaded from
disk) and not for data (e.g. variables).</p>
<p>Neotron OS has no support for memory refresh. If this is required, it must be
arranged by the BIOS in the background.</p>
<h3><a class="header" href="#system_interrupt_query" id="system_interrupt_query">system_interrupt_query</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InterruptMask(u16);

enum Interrupt {
	ExtInterrupt0,
	ExtInterrupt15
}

type InterruptFunction = fn(interrupt: Interrupt);

fn system_interrupt_enable(interrupt: Interrupt);

fn system_interrupt_get_enabled() -&gt; InterruptMask;

fn system_interrupt_disable(interrupt: Interrupt);

fn system_interrupt_hook(interrupt: Interrupt, fn: InterruptFunction) -&gt; Option&lt;InterruptFunction&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>The Neotron BIOS has up to 16 external interrupts, numbered 0 to 15. Note that
this only applies to <em>external</em> interrupts - that is, from expansion cards
fitted to expansion slots, or peripherals on the baseboard that are connected
like expansion cards. These functions do not apply to internal interrupts (e.g. for UART data received) - see the device specific APIs for any interrupt support that may be available.</p>
<h3><a class="header" href="#system_reboot" id="system_reboot">system_reboot</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn system_reboot() -&gt; !;
<span class="boring">}
</span></code></pre></pre>
<p>Reboots the system.</p>
<h3><a class="header" href="#system_halt" id="system_halt">system_halt</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn system_halt() -&gt; !;
<span class="boring">}
</span></code></pre></pre>
<p>Halts the system. The OS should display some 'This system is now safe to power off' message first, in case the hardware can't actually power itself off.</p>
<h3><a class="header" href="#sytem_control" id="sytem_control">sytem_control</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sytem_control(command: u32, data: *const u8, data_len: usize) -&gt; Result&lt;u32, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Sends a BIOS-specific command. See your BIOS user guide for details.</p>
<h2><a class="header" href="#serial-ports-uarts" id="serial-ports-uarts">Serial Ports (UARTs)</a></h2>
<h3><a class="header" href="#serial_get_info" id="serial_get_info">serial_get_info</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SerialType {
	/// An RS-232 interface, but at TTL voltages. Typically used with an
	/// FTDI FT232 cable.
	TtlUart,
	/// An RS-232 interface
	Rs232,
	/// A USB Device implementing Communications Class Device (also known as
	/// a USB Serial port). The USB Device implementation may be on-chip
	/// (handled by the BIOS), or off-chip.
	UsbCdc,
	/// A MIDI interface
	Midi,
	/// A Commodore Serial interface
	Cbm,
	/// An RS-485 bus
	Rs485,
}

struct SerialInfo {
	name: ApiStrRef,
	type: SerialType,
}

fn serial_get_info(device_idx: u8) -&gt; Option&lt;SerialInfo&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Get information about the Serial ports in the system. Serial ports are ordered
octet-oriented pipes. You can push octets into them using a 'write' call, and
pull bytes out of them using a 'read' call. They have options which allow them
to be configured at different speeds, or with different transmission settings
(parity bits, stop bits, etc) - you set these with a call to <code>SerialConfigure</code>.
They may physically be a MIDI interface, an RS-232 port or a USB-Serial port.
There is no sense of 'open' or 'close' - that is an Operating System level
design feature. These APIs just reflect the raw hardware, in a similar manner to
the registers exposed by a memory-mapped UART peripheral.</p>
<h3><a class="header" href="#serial_configure" id="serial_configure">serial_configure</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SerialParity {
	Odd,
	Even,
	None
}

enum SerialHandshaking {
	None,
	RtsCts,
}

enum SerialStopBits {
	One,
	Two
}

enum SerialDataBits {
	Seven,
	Eight,
}

struct SerialConfig {
	data_rate_bps: u32,
	data_bits: SerialDataBits,
	stop_bits: SerialStopBits,
	parity: SerialParity,
	handshaking: SerialHandshaking,
}

fn serial_configure(device_idx: u8, config: Option&lt;SerialConfig&gt;) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Set the options for a given serial device. An error is returned if the options
are invalid for that serial device (e.g. you have picked a data rate that isn't
supported).</p>
<p>Passing <code>None</code> will power-down and/or deactivate the peripheral to the extent
supported by the peripheral.</p>
<h3><a class="header" href="#serial_write" id="serial_write">serial_write</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serial_write(device_idx: u8, data: &amp;[u8], timeout: Option&lt;Timeout&gt;) -&gt; Result&lt;usize, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Write octets to a serial port. There is no sense of 'opening' or 'closing' the
device - serial devices are always open. If the return value is <code>Ok(n)</code>, the
value <code>n</code> may be less than <code>data.len()</code>. If so, that means not all of the data
could be transmitted - only the first <code>n</code> octets were.</p>
<h3><a class="header" href="#serial_read" id="serial_read">serial_read</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serial_read(device_idx: u8, buffer: &amp;mut [u8], timeout: Option&lt;Timeout&gt;) -&gt; Result&lt;usize, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Read octets from a serial port. There is no sense of 'opening' or 'closing'
the device - serial devices are always open. If the return value is <code>Ok(n)</code>,
the value <code>n</code> may be equal or less than <code>buffer.len()</code> (never great). If less,
that means not all of the buffer could be filled with received data - only the
first <code>n</code> octets were.</p>
<h3><a class="header" href="#serial_flush_write" id="serial_flush_write">serial_flush_write</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serial_flush_write(device_idx: u8, timeout: Option&lt;Timeout&gt;) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Wait until any bytes previously accepted by <code>serial_write</code> have actually left the
UART device (as opposed to just sitting in a hardware buffer).</p>
<h3><a class="header" href="#serial_flush_read" id="serial_flush_read">serial_flush_read</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serial_flush_read(device_idx: u8, timeout: Option&lt;Timeout&gt;) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Empty any serial buffers so that, if no further characters are received on the UART, <code>serial_read</code> will return <code>Ok(0)</code>.</p>
<h3><a class="header" href="#serial_interrupt_register" id="serial_interrupt_register">serial_interrupt_register</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SerialInterruptFlag {
	/// `serial_read` will return a non-zero value.
	RxReady = 1,
	/// The last `serial_write` has completed.
	TxComplete = 2,
	/// A *break* condition has been received
	Break = 4
}

struct SerialInterruptFlagSet(u32);

type SerialCallback = Fn(device_idx: u8, flags: SerialInterruptFlagSet);

fn serial_interrupt_register(device_idx: u8, function: SerialCallback, flags: SerialInterruptFlagSet) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>When any of the properties specified in <code>flags</code> are true, the given <code>function</code>
will be executed from the hardware interrupt handler. Note that calling Neotron
BIOS functions from interrupt handlers is not, in general, supported, and so the
callback should set some state and to inform the main thread that something has
occurred.</p>
<h2><a class="header" href="#current-time" id="current-time">Current Time</a></h2>
<h3><a class="header" href="#timestamp_get" id="timestamp_get">timestamp_get</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn timestamp_get() -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Returns a value indicating how long the system has been running. This is typically the number of video lines generated since the system was powered on. This value is guaranteed to always be greater than (or equal to) the last time this function was called - unless the system is rebooted.</p>
<h3><a class="header" href="#timestamp_rate" id="timestamp_rate">timestamp_rate</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn timestamp_rate() -&gt; u16
<span class="boring">}
</span></code></pre></pre>
<p>Returns the number of timestamp ticks in a second. You can use this to convert the difference between two <code>TimestampGet</code> values into a duration in seconds.</p>
<h3><a class="header" href="#time_get" id="time_get">time_get</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Time {
	seconds_since_epoch: u32,
	ticks_since_second: u16
}

fn time_get() -&gt; Time;
<span class="boring">}
</span></code></pre></pre>
<p>Get the current wall time. The Neotron BIOS does not understand time zones,
leap-seconds or the Gregorian calendar. Nor does it promise that time is
monotonic - users can (and will) move the clock backwards and forwards in time.
It simply stores time as an incrementing number of seconds since some epoch, and
the number of ticks (typically 60 Hz, but see <code>TimestampRate</code>) since that second
began. A day is assumed to be exactly 86,400 seconds long. This is a lot like
POSIX time, except we have a different epoch - the Neotron epoch is
2000-01-01T00:00:00Z. It is highly recommend that you store UTC in the BIOS and
use the OS to handle time-zones.</p>
<h3><a class="header" href="#time_set" id="time_set">time_set</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn time_set(time: Time);
<span class="boring">}
</span></code></pre></pre>
<p>Set the current wall time to the given value. See <a href="bios_apicalls.html#timeget">TimeGet</a>.</p>
<h2><a class="header" href="#i2c-bus" id="i2c-bus">I2C Bus</a></h2>
<h3><a class="header" href="#i2c_bus_get_info" id="i2c_bus_get_info">i2c_bus_get_info</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum I2CBusSpeed {
	// 10kbps
	Low,
	/// 100kbps
	Standard,
	/// 400kbps
	Fast,
	/// 1Mbps
	FastPlus,
	/// 3.4Mbps
	High,
	/// 5Mbps
	UltraFast,
}

struct I2CBusInfo {
	name: ApiStrRef,
	supported_speeds: &amp;[I2CBusSpeed],
}

fn i2c_bus_get_info(bus_idx: u8) -&gt; Option&lt;I2CBusInfo&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Gets information about the I2C buses in the system..</p>
<h3><a class="header" href="#i2c_bus_set_speed" id="i2c_bus_set_speed">i2c_bus_set_speed</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn i2c_bus_set_speed(bus_idx: u8, speed: I2CBusSpeed) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Set the I2C bus speed.</p>
<h3><a class="header" href="#i2c_device_write_read" id="i2c_device_write_read">i2c_device_write_read</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn i2c_device_write_read(bus_idx: u8, address: u8, out_buffer: &amp;[u8], in_buffer: &amp;mut [u8]) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Writes data to the I2C bus, then reads data. Performs the following operations (courtesy of the Embedded HAL documentation):</p>
<pre><code>		  +---+-----+---+--+---+--+---+---+--+---+--+-----+---+--+---+--+---+---+--+----+--+
	 Main | ST|SAD+W|   |O0|   |O1|   |...|OM|   |SR|SAD+R|   |  |MAK|  |MAK|...|  |NMAK|SP|
		  +---+-----+---+--+---+--+---+---+--+---+--+-----+---+--+---+--+---+---+--+----+--|
Secondary |   |     |SAK|  |SAK|  |SAK|...|  |SAK|  |     |SAK|I0|   |I1|   |...|IN|    |  |
		  +---+-----+---+--+---+--+---+---+--+---+--+-----+---+--+---+--+---+---+--+----+--+
</code></pre>
<p>Where:</p>
<ul>
<li>ST = start condition
* SAD+W = secondary address followed by bit 0 to indicate writing
* SAK = secondary acknowledge
* Oi = ith outgoing byte of data
* SR = repeated start condition
* SAD+R = secondary address followed by bit 1 to indicate reading
* Ii = ith incoming byte of data
* MAK = main acknowledge
* NMAK = main no acknowledge
* SP = stop condition</li>
</ul>
<p>The given address must in the range <code>1..127</code>. The BIOS does not handle device detection or even know what devices are fitted - that is all handled in the operating system.</p>
<h2><a class="header" href="#spi-bus" id="spi-bus">SPI Bus</a></h2>
<h3><a class="header" href="#spi_bus_get_info" id="spi_bus_get_info">spi_bus_get_info</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SpiBusInfo {
	/// A name for this SPI bus
	name: ApiStrRef,
	/// The number of unique chip select signals associated with this SPI bus
	num_chip_selects: u8,
	/// The maximum SPI bus speed supported
	max_bus_speed_bps: u32,
	/// Will be 1, 2 or 4
	max_bus_width_bits: u8,
}

fn spi_bus_get_info(bus_idx: u8) -&gt; Option&lt;SpiBusInfo&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Gets information about the SPI buses in the system.</p>
<h3><a class="header" href="#spi_bus_configure" id="spi_bus_configure">spi_bus_configure</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SpiMode {
	Mode0,
	Mode1,
	Mode2,
	Mode3
}

struct SpiBusConfig {
	bus_speed_bps: u32,
	bus_width_bits: u8,
	mode: SpiMode
}

fn spi_bus_configure(bus_idx: u8, config: Option&lt;SpiBusConfig&gt;) -&gt; Result&lt;u32, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Configure the SPI bus. Where arbitrary speeds are not supported by the bus, the
BIOS will select the closest supported speed which is not greater than the given
speed.</p>
<h3><a class="header" href="#spi_device_transfer" id="spi_device_transfer">spi_device_transfer</a></h3>
<p>Write to and read from an SPI device.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MutableDataBuffer&lt;'a&gt; {
	U8(&amp;'a mut [u8]),
	U16(&amp;'a mut [u16]),
	U32(&amp;'a mut [u32]),
}

fn spi_device_transfer(bus_idx: u8, device_idx: u8, word_size: u8, buffer: MutableDataBuffer) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Writes data to an SPI device and reads data from the same SPI simultaneously. Data is both read from and written to the same buffer. When writing with a word size of 8 or less, each word should be stored in the least-significant bits of each <code>u8</code> in a <code>MutableDataBuffer::U8</code>. When writing with a word size of <code>8 &lt; x &lt;= 16</code>, each word should be stored in the least-significant bits of each <code>u16</code> in a <code>MutableDataBuffer::U16</code>. When writing with a word size of <code>16 &lt; x &lt;= 32</code>, each word should be stored in the least-significant bits of each <code>u32</code> in a <code>MutableDataBuffer::U32</code>.</p>
<h3><a class="header" href="#spi_device_write" id="spi_device_write">spi_device_write</a></h3>
<p>Write to an SPI device, discarding any read data.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DataBuffer&lt;'a&gt; {
	U8(&amp;'a [u8]),
	U16(&amp;'a [u16]),
	U32(&amp;'a [u32]),
}

fn spi_device_write(bus_idx: u8, device_idx: u8, buffer: DataBuffer) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#universal-serial-bus" id="universal-serial-bus">Universal Serial Bus</a></h2>
<h3><a class="header" href="#usbxxx" id="usbxxx">USBxxx</a></h3>
<p>This is where the Neotron system is a USB Host and the OS wants to access any attached USB devices.</p>
<p><em>TODO: Add a bunch of functions here along the lines of the USB OHCI. Then check we can implement them using a Tiva-C 123 and an STM32H7.</em></p>
<h2><a class="header" href="#general-purpose-inputoutput" id="general-purpose-inputoutput">General-Purpose Input/Output</a></h2>
<h3><a class="header" href="#gpio_port_get_info" id="gpio_port_get_info">gpio_port_get_info</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GpioPortInfo {
	name: ApiStrRef,
	num_pins: u8,
}

#[derive(Copy, Clone)]
struct GpioPort(pub u8);

#[derive(Copy, Clone)]
struct GpioPin(pub u8);

#[derive(Copy, Clone)]
struct GpioPinMask(pub u32);

fn gpio_port_get_info(port: GpioPort) -&gt; Option&lt;GpioPortInfo&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Gets information about the GPIO ports on this system. Note that each GPIO port can only have up to 32 pins.</p>
<h3><a class="header" href="#gpio_pin_get_info" id="gpio_pin_get_info">gpio_pin_get_info</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum GpioPinMode {
	InputFloating,
	InputPullUp,
	InputPullDown,
	Output,
	OutputOpenCollector,
}

struct GpioPinInfo {
	name: ApiStrRef,
	state: GpioPinMode
}

fn gpio_pin_get_info(port: GpioPort, pin: GpioPin) -&gt; Option&lt;GpioPinInfo&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Gets information about the GPIO pins on a specific port.</p>
<h3><a class="header" href="#gpio_pin_set_mode" id="gpio_pin_set_mode">gpio_pin_set_mode</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gpio_pin_set_mode(port: GpioPort, pin: GpioPin, mode: GpioPinMode) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Sets the mode for a GPIO pin.</p>
<h3><a class="header" href="#gpio_port_set_mode" id="gpio_port_set_mode">gpio_port_set_mode</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gpio_port_set_mode(port: GpioPort, mode: &amp;[Option&lt;GpioPinMode&gt;]) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Sets the mode for a number of pins in a GPIO port. The length of <code>mode</code> must be in the range 1 to <code>num_pins</code>. You can pass <code>None</code> to leave a pin's mode unchanged.</p>
<h3><a class="header" href="#gpio_pin_set_level" id="gpio_pin_set_level">gpio_pin_set_level</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gpio_pin_set_level(port: GpioPort, pin: GpioPin, level: bool) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Sets the output level for an Output GPIO pin. The behaviour if this pin is not currently configured as an output is undefined.</p>
<h3><a class="header" href="#gpio_port_set_levels" id="gpio_port_set_levels">gpio_port_set_levels</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gpio_port_set_levels(port: GpioPort, mask: GpioPinMask, levels: u32) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Sets the level for a number of pins in a GPIO port. Only pins with a corresponding <code>1</code> bit in <code>mask</code> get set to the corresponding bit in <code>level</code>.</p>
<h3><a class="header" href="#gpio_pin_get_level" id="gpio_pin_get_level">gpio_pin_get_level</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gpio_pin_get_level(port: GpioPort, pin: GpioPin) -&gt; Result&lt;bool, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Gets the input level for an Input GPIO pin. The behaviour if this pin is not currently configured as an input is undefined.</p>
<h3><a class="header" href="#gpio_port_get_levels" id="gpio_port_get_levels">gpio_port_get_levels</a></h3>
<p>Gets the level for a number of pins in a GPIO port. Only pins with a corresponding <code>1</code> bit in <code>mask</code> get a bit set in the returned value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gpio_port_get_levels(port: GpioPort, mask: GpioPinMask) -&gt; Result&lt;u32, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#delay-functions" id="delay-functions">Delay functions</a></h2>
<h3><a class="header" href="#delay" id="delay">delay</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delay(period: Timeout);
<span class="boring">}
</span></code></pre></pre>
<p>Delays for at least a given amount of time. Because some systems have lengthy
interrupt routines (e.g. CPU powered video rendering), the application may be
delayed for considerably more than the requested period (but never less than
the requested period).</p>
<h3><a class="header" href="#delay_vblank" id="delay_vblank">delay_vblank</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delay_vblank();
<span class="boring">}
</span></code></pre></pre>
<p>Delays until the next vertical blanking interval. That is, it waits until the screen has finished drawing and the raster beam is in the off-screen portion. During this time the video memory can be safely updated without causing tearing on the screen. Only supported if you have built-in video.</p>
<h2><a class="header" href="#video-functions" id="video-functions">Video functions</a></h2>
<h3><a class="header" href="#video_mode_get_info" id="video_mode_get_info">video_mode_get_info</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct VideoMode(pub u8);

enum VideoAttrFormat {
	// No attribute bytes
	None,
	// Suports the given number of foreground and background colours
	IndexColour(u8),
}

struct VideoTextModeInfo {
	/// Number of columns of text on screen
	width: u8,
	/// Number of rows of text on screen
	height: u8,
	/// Number of bytes per row (must be &gt;= cols * 2)
	row_size: usize,
	/// Do we support colour or other attributes?
	attr_format: VideoAttrFormat,
	/// How many pages of text are available
	num_pages: u8,
	/// Can the user supply a new bitmap font? If so, see `VideoModeFontSet`.
	support_soft_font: bool,
}

enum ChunkyPixelFormat {
	/// 1 bit per pixel monochrome.
	Grey1,
	/// 8-bit greyscale (256 shades of grey), packed as one pixel per byte.
	Grey8,
	/// 4-bit colour (16 colours), packed two pixels per byte, with pallette lookup.
	Indexed8,
	/// 8-bit colour (256 colours), packed as one pixel per byte, with pallette lookup.
	Indexed8,
	/// 16-bit colour (65536 colours), using two bytes per pixel.
	Colour16,
	/// 24-bit colour, packed in four-byte words.
	Colour32
}

struct VideoChunkyBitmapModeInfo {
	/// Number of pixels across the screen
	width: u16,
	/// Number of pixels down the screen
	height: u16,
	/// Number of bytes per row (must be &gt;= width * bits-per-pixel / 8)
	row_size: usize,
	/// How many pages of video are available (e.g. 2 for double-buffering)
	num_pages: u8,
	/// What format are the pixels in? Determines how many bits are required for each pixel.
	pixel_format: ChunkyPixelFormat,
	/// How big each pallette entry is. '4' would mean each pallette entry gives a 4-bit (16-colour) value
	/// (like CGA), whilst 18 would mean each pallette entry gave an 18-bit
	/// (262,144-colour) value (like VGA)
	pallete_entry_size_bits: u8,
}

enum PlanarPixelFormat {
	/// 2 planes, 1-bpp each, for 4 colours (with pallette look-up)
	Colour2,
	/// 3 planes, 1-bpp each, for 8 colours (with optional pallette look-up)
	Colour3,
	/// 4 planes, 1-bpp each, for 16 colours (with optional pallette look-up)
	Colour4,
	/// 3 planes, 8-bpp (i.e. one byte per pixel) each (24-bit true-colour)
	Colour3x8,
}

struct VideoPlanarBitmapModeInfo {
	/// Number of pixels across the screen
	width: u16,
	/// Number of pixels down the screen
	height: u16,
	/// Number of bytes per row (must be &gt;= width * bits-per-pixel / 8)
	row_size: usize,
	/// How many pages of video are available (e.g. 2 for double-buffering)
	num_pages: u8,
	/// What format are the pixels in? Determines how many bitplanes are required for each pixel.
	pixel_format: PlanarPixelFormat,
	/// How big each pallette entry is. '4' would mean each pallette entry gives a 4-bit (16-colour) value
	/// (like CGA), whilst 18 would mean each pallette entry gave an 18-bit
	/// (262,144-colour) value (like VGA)
	pallete_entry_size_bits: u8,
}

enum VideoModeInfo {
	Disabled,
	Text(VideoTextModeInfo),
	ChunkyBitmap(VideoChunkyBitmapModeInfo),
}

fn video_mode_get_info(mode: VideoMode) -&gt; Option&lt;VideoModeInfo&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Gets information about a specific video mode. Returns <code>None</code> if that video mode is not supported. Video Mode 0 is always 'no video' - i.e. the video output is disabled or not available.</p>
<h3><a class="header" href="#video_mode_get" id="video_mode_get">video_mode_get</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_mode_get() -&gt; VideoMode;
<span class="boring">}
</span></code></pre></pre>
<p>Gets which video mode the system is currently in. A value of zero means video is currently disabled.</p>
<h3><a class="header" href="#video_mode_set" id="video_mode_set">video_mode_set</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_mode_set(mode: VideoMode) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Selects a new video mode. Selecting any mode where <code>VideoModeGetInfo(mode)</code> returns <code>None</code> will give an error. </p>
<h3><a class="header" href="#video_font_get" id="video_font_get">video_font_get</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FontInfo {
	font: *const u8,
	font_len: usize,
	glyph_width_pixels: u8,
	glyph_height_rows: u8,
}

fn video_font_get() -&gt; Result&lt;FontInfo, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Get a information about the currently loaded bitmap font. See <a href="bios_apicalls.html#video_font_set">video_font_set</a>.</p>
<h3><a class="header" href="#video_font_set" id="video_font_set">video_font_set</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_font_set(font_info: FontInfo) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Change the current bitmap font. Pixel data is laid out row-wise, with each row of each glyph packed into an integer number of bytes. For example, a 7-pixel wide glyph is packed into bytes (leaving the LSB unused), whilst a 9-pixel glyph is packed into two bytes as a big-endian 16-bit value, leaving the 7 LSBs of the second (low) byte unused.</p>
<p>An error is returned if the current mode doesn't support soft fonts, or if the width/height parameters are not compatible with the current mode, or if the <code>font_len</code> does not equal <code>int((glyph_width_pixels + 7) / 8) * glyph_height_rows * 256</code>.</p>
<p>Neotron uses 8-bit fonts, so there are only 256 glyphs in a font. Unicode text must be mapped to this set of glyphs for display on-screen. Alternative the OS can implement its own rendering system and simply draw pixels using the BIOS.</p>
<p>The standard Neotron fonts match MS-DOS / IBM Code Page 850, but user-supplied fonts can do anything (they don't even have to be characters - they could be background tiles for a game, for example).</p>
<h3><a class="header" href="#video_page_set" id="video_page_set">video_page_set</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_page_set(page: u8) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Changes the currently displayed video page (if the current video mode supports multiple pages).</p>
<h3><a class="header" href="#video_text_scroll" id="video_text_scroll">video_text_scroll</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_text_scroll(line: u8) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Changes which 'line' of the text buffer is displayed at the top of the screen. When the text renderer gets the bottom of the text buffer, it starts taking lines from the top of the buffer.</p>
<p>The default start line is 0, giving:</p>
<pre><code>+----------+
| Line 0   |
| Line 1   |
| Line 2   |
:          :
| Line N-3 |
| Line N-2 |
| Line N-1 |
+----------+
</code></pre>
<p>Setting the start line to 2, will give:</p>
<pre><code>+----------+
| Line 2   |
| Line 3   |
| Line 4   |
:          :
| Line N-1 |
| Line 0   |
| Line 1   |
+----------+
</code></pre>
<h3><a class="header" href="#video_text_write" id="video_text_write">video_text_write</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_text_write(
	top_left: VideoCoord, bottom_right: VideoCoord,
	text: &amp;[u8],
	foreground: u8, background: u8);
<span class="boring">}
</span></code></pre></pre>
<p>Write text to the display, using the given indexed foreground and background
colours. The written text will wrap inside the video rectangle, but does not
understand carriage return characters, new-line characters or any other screen
formatting - each value simply selects one of 256 glyphs to be displayed at
that position on the screen.</p>
<h3><a class="header" href="#video_pixel_set" id="video_pixel_set">video_pixel_set</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum VideoColour {
	Binary(bool),
	Indexed(u8),
	High(u16),
	True(u8, u8, u8)
}

struct VideoCoord {
	x: u16,
	y: u16
}

fn video_pixel_set(pos: VideoCoord, colour: VideoColour);
<span class="boring">}
</span></code></pre></pre>
<p>Sets a single pixel at the given location to the given colour.</p>
<p>This function is not supported if video is currently disabled, or in a text mode.</p>
<h3><a class="header" href="#video_pixel_set_rect" id="video_pixel_set_rect">video_pixel_set_rect</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_pixel_set_rect(
	top_left: VideoCoord,
	bottom_right: VideoCoord,
	colour: VideoColour);
<span class="boring">}
</span></code></pre></pre>
<p>Sets multiple pixels to the same value, as specified by the rectangle given by
<code>top_left</code> to <code>bottom_right</code>.</p>
<p>This function is not supported if video is currently disabled, or in a text mode.</p>
<h3><a class="header" href="#video_pixel_blit_raw" id="video_pixel_blit_raw">video_pixel_blit_raw</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn video_pixel_blit_raw(
	top_left: VideoCoord,
	bottom_right: VideoCoord,
	source: *const u8);
<span class="boring">}
</span></code></pre></pre>
<p>Draws pixel data onto the screen, in the region specified by the rectangle
given by <code>top_left</code> to <code>bottom_right</code>. The supplied pixel data must be in the
same format as the screen.</p>
<p>The buffer pointed to by <code>source</code> must be at least <code>(1 + bottom_right.x - top_left.x) * (1 + bottom_right.y - top_left.y)</code> pixels in length where the
length of a pixel in bytes depends on the current video mode.</p>
<p>This function is not supported if video is currently disabled, or in a text mode.</p>
<h3><a class="header" href="#video_pixel_blit" id="video_pixel_blit">video_pixel_blit</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_pixel_blit(
	top_left: VideoCoord,
	bottom_right: VideoCoord,
	foreground: VideoColour,
	background: VideoColour,
	source: *const u8);
<span class="boring">}
</span></code></pre></pre>
<p>Draws monochrome greyscale pixel data to the screen - where a bit is set in
the source data the <code>foreground</code> colour is used, otherwise the <code>background</code>
colour is used. You might use this to draw text to a bitmap display, for
example.</p>
<p>The buffer pointed to by <code>source</code> must be at least <code>(1 + bottom_right.x - top_left.x) * (1 + bottom_right.y - top_left.y)</code> pixels in length.</p>
<p>This function is not supported if video is currently disabled, or in a text mode.</p>
<h3><a class="header" href="#video_blit" id="video_blit">video_blit</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_blit(
	top_left: VideoCoord,
	bottom_right: VideoCoord,
	source: &amp;[VideoColour]);
<span class="boring">}
</span></code></pre></pre>
<p>Draws pixel data onto the screen, in the region specified by the rectangle
given by <code>top_left</code> to <code>bottom_right</code>. The supplied pixel data will be
converted to screen format as required.</p>
<p>The slice <code>source</code> must be at least <code>(1 + bottom_right.x - top_left.x) * (1 + bottom_right.y - top_left.y)</code> elements in length.</p>
<p>This function is not supported if video is currently disabled, or in a text mode.</p>
<h3><a class="header" href="#video_draw_line" id="video_draw_line">video_draw_line</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_draw_line(
	start: VideoCoord,
	end: VideoCoord,
	colour: VideoColour);
<span class="boring">}
</span></code></pre></pre>
<p>Draws a line from <code>start</code> to <code>end</code>, applying the colour given by <code>colour</code> (see <code>video_pixel_set</code>).</p>
<p>This function is not supported if video is currently disabled, or in a text mode.</p>
<h3><a class="header" href="#video_draw_rect" id="video_draw_rect">video_draw_rect</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn video_draw_rect(
	top_left: VideoCoord,
	bottom_right: VideoCoord,
	colour: VideoColour);
<span class="boring">}
</span></code></pre></pre>
<p>Sets multiple pixels to the same value, as specified by the rectangle given by
<code>top_left</code> to <code>bottom_right</code>. Only the outer edge is filled - the interior of
the rectangle is unchanged.</p>
<p>This function is not supported if video is currently disabled, or in a text mode.</p>
<h3><a class="header" href="#video_hook_scanline" id="video_hook_scanline">video_hook_scanline</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type VideoHookCallback = fn(usize, u16);
fn video_hook_scanline(context: usize, scan_line: u16, fn: VideoHookCallback) -&gt; Result&lt;(), Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Supply a function to be called just before the given scan-line is rendered. The function is called in Interrupt Context, and so may pre-empt other functions. The function is automatically un-hooked before it is called, and it is safe for the called function to re-hook itself, or to hook some other function, using <code>video_hook_scanline</code> but it is not safe to call any other BIOS function.</p>
<p>This function is not supported if video is currently disabled. Passing a value
of <code>scan_line</code> which is out of bounds for the current video mode will return
an error.</p>
<h1><a class="header" href="#the-neotron-os" id="the-neotron-os">The Neotron OS</a></h1>
<p>The Neotron OS is the hardware-agnosting implementation of the Neotron API. It uses the BIOS to interact with the hardware, allowing it to run on different hardware platforms with the minimum number of changes.</p>
<pre><code>+-------+-------------+
|       |             |
| Shell | Application |
|       |             |
+=======+=============+
|                     |
|  Operating System   |
|                     |
+=====================+
|                     |
|        BIOS         |
|                     |
+---------------------+
|                     |
|    Raw Hardware     |
|                     |
+---------------------+
</code></pre>
<p>It should implement:</p>
<ul>
<li>File/Device handling (open, read, write, seek, etc)</li>
<li>A FAT16/32 compatible filesystem with MS-DOS MBR partitions (max 2 TiB disk size - 2<sup>32</sup> sectors of 512 bytes)</li>
<li>A text-mode console, with cursor</li>
<li>Basic line-based input and character based raw input</li>
<li>Simple bitmap graphics primitives (lines, rectangles, fill, etc)</li>
<li>An audio synthesiser</li>
<li>Input/output stream handling</li>
<li>Digital (Atari) joystick support</li>
<li>A TCP/IP networking stack</li>
<li>MIDI support</li>
<li>Jumping to applications located in RAM or ROM, giving them access to the OS</li>
<li>Supporting special 'shell' applications which can chain-load small programs (e.g. command-line utilities) without being unloaded</li>
<li>Memory allocation/deallocation routines</li>
<li>Run-time volume mounting/unmounting</li>
</ul>
<p>Selected non-goals (i.e. things we aren't going to support) include:</p>
<ul>
<li>Co-operative multi-tasking</li>
<li>Pre-emptive multi-threading</li>
<li>Virtual Memory (although we might support a special API for paging to and from disk)</li>
<li>Processes / process isolation</li>
</ul>
<p>Our ultimate goal is that one day we could offer a version of the Rust Standard Library (<code>std</code>) which uses the Neotron OS API - albeit without the sub-process and thread support.</p>
<p>Programming on the Neotron usually involves first loading the specific interpreter for that language - unless you've swapped out the standard shell for something like a BASIC interpreter.</p>
<h2><a class="header" href="#filename-convention" id="filename-convention">Filename Convention</a></h2>
<p>Files live in volumes. Volumes on fixed or removable disks must be formatted with the FAT12, FAT16 or FAT32 filesystem and live either live in a disk partition identified by a PC Master Boot Record (with a suitable Filesystem Type), or live at the start of the drive. Volumes are allocated a volume number, starting with <code>0:</code>, then <code>1:</code> etc. File paths are relative to a volume number. Paths are separated with a <code>/</code> character. The root directory is called <code>/</code>.</p>
<p>When a volume has a name, you can refer to it as <code>&lt;name&gt;:</code> instead of <code>&lt;id&gt;:</code>. For example <code>work:/Documents/hello.txt</code> refers to a file called <code>hello.txt</code> inside a folder called <code>Documents</code> which lives on a volume called <code>work</code>.</p>
<p>It is an error to try and create a file containing a <code>:</code> character. Any files or directories which do contain invalid characters are as if the character was replaced with <code>_</code>. When a directory contains multiple files with the same name, any attempt to read the file will only be able to access the one that is found first. Any attempt to create a new file will cause any existing files of the same name in the same folder to be deleted.</p>
<p>For example:</p>
<pre><code class="language-console">0:/&gt; dir 1:
Listing files in 1:/
FOO.TXT      1234  2019-10-17 23:20:01 A--
COMMANDS.SH    34  2019-10-17 23:20:11 AR-
FOLDER       &lt;DIR&gt; 2019-09-13 20:20:11 D--

0:/&gt; dir 1:/FOLDER
Listing files in 1:/FOLDER
BAR.TXT      1234  2019-10-18 10:11:13 ---

0:/&gt; cd 1:/FOLDER

1:/FOLDER&gt; dir
Listing files in 1:/FOLDER
BAR.TXT      1234  2019-10-18 10:11:13 ---

1:/&gt;
</code></pre>
<p>Unlike MS-DOS, which has a separate <em>current directory</em> for each volume (i.e. drive letter), Neotron maintains a UNIX-like single <em>current directory</em> which includes the name of the current volume. Where a volume is given without a directory path, the root directory (<code>/</code>) is presumed.</p>
<h2><a class="header" href="#file-permissions" id="file-permissions">File Permissions</a></h2>
<p>Files can be opened as read-only (write-none), write-truncate or write-append. Because Neotron is single-tasking and non-re-entrant, there is no support for lock files or exclusive file creation, but files are locked when they are opened so they can only be opened once at any one time. Files on disk support the standard FAT16/FAT32 attributes - Archive, Read-Only, Hidden and System. Seeking uses 64-bit byte offsets, although note that FAT32 limits files to 4 GiB in size.</p>
<h2><a class="header" href="#file-operations" id="file-operations">File Operations</a></h2>
<p>A file handle, whether pointing to a file on a volume, or to a <a href="os.html#special-devices">Special Device</a>, generally has the following functions available. These functions broadly follow the POSIX model.</p>
<ul>
<li>
<p><code>read</code> - obtain some bytes from this handle. A <code>&amp;mut [u8]</code> is supplied, and either an integer is returned which reports how many bytes in that buffer were filled by the function call, or an error is returned. The call will wait until the buffer is full, or the timeout has been met - the timeout may be zero, some finite value, or infinite. Some files (e.g. block devices) only support reading fixed size blocks and attempts to read any other size block will give an error.</p>
</li>
<li>
<p><code>write</code> - sent some bytes to this handle. A <code>&amp;[u8]</code> is supplied, and either an integer is returned which reports how many bytes from that buffer were sent by the function call, or an error is returned. The call will wait until all the bytes have been sent, or the timeout has been met - the timeout may be zero, some finite value, or infinite.  Some files (e.g. block devices) only support writing fixed size blocks and attempts to write any other size block will give an error.</p>
</li>
<li>
<p><code>seek</code> - adjust the current pointer in the file. Files opened for reading start with the pointer at the beginning. Files opened for writing start with the pointer at the end. Some special devices are not seekable and this function will return an error. The pointer can be adjusted with a number of bytes relative to a) the current position, b) the start of the file, or c) the end of the file. Seeking beyond the end of a file on disk is not supported.  Some files (e.g. block devices) only support seeking to particular offsets (e.g. a multiple of the block size) and attempting to seek to any other offset will give an error.</p>
</li>
</ul>
<h2><a class="header" href="#special-devices" id="special-devices">Special Devices</a></h2>
<p>There are special devices which look like files, but are not. They have names which are like volumes, but contain a '$' character. It is an error to try and use a regular volume with <code>$</code> in the name. Where the device name contains an <code>x</code>, the <code>x</code> should be replaced with a single digit (e.g. 0 or 1) to identify a specific device.</p>
<ul>
<li><code>CON$:</code> - The console. You can read from here to get line-buffered text input and write here to put UTF-8 text on the screen (with ANSI code sequence support).</li>
<li><code>KBD$:</code> - The raw keyboard. You can read from here to get raw keyboard events (such as Up Arrow key, or Page Down).</li>
<li><code>TIME$:</code> - Gets/sets the system time (read/write).</li>
<li><code>GFX$:</code> - A bitmap framebuffer device.</li>
<li><code>PRNx$:</code> - A printer. Write here to send data to the printer, read to get print status.</li>
<li><code>DISCx$:</code> - An SD card or other block device (can read/write raw 512 byte blocks).</li>
<li><code>SERx$:</code> - An RS-232 serial device (read/write).</li>
<li><code>TONEx$:</code> - A tone generator device (write-only).</li>
<li><code>PCMx$:</code> - A PCM device (write for playback, read for record).</li>
<li><code>JSx$:</code> - A Joystick (read-only).</li>
</ul>
<p>Additional parameters may be specified after the <code>$</code>, separated by <code>;</code>. For example:</p>
<ul>
<li><code>SER0$bps=9600;parity=N;timeout=100:</code> - The first RS-232 serial device, at 9600 bps, with a 100 frame read/write timeout.</li>
<li><code>PCM0$channels=2;bit=8;samplerate=8000:</code> - A PCM interface configured for stereo 8kHz 8-bit.</li>
</ul>
<p>Special devices do not support filenames or paths. To access something like a network volume, the volume must be mounted and given a normal volume ID. The API for this is TBD.</p>
<h3><a class="header" href="#writing-to-con" id="writing-to-con">Writing to <code>CON$:</code></a></h3>
<p>The Console device <code>CON$:</code>, like every other file, is a bi-direction octet pipe. Unfortunately, one octet is not enough to represent the full set of characters a modern computer needs to support. Rust handles this by insisting that text (<code>&amp;str</code> string slices and <code>String</code> owned strings) is in Unicode Translation Format 8 (UTF-8). This is a mechanism by which Unicode characters (which are around 21 bits in size) can be encoded as between one and six octets. The useful property is that the first 127 Unicode characters map to a single octet, which makes it interchangeable with standard ASCII.</p>
<p>In text mode, most Neotron systems will only have one octet avilable per text cell to record which particular character being displayed in that cell, therefore placing a limit of 256 different glyphs in any given font. The font must therefore also provide a translation function which can convert from a 21-bit Unicode character to an octet for storage in the screen buffer. Typically the fonts will follow some standard 8-bit <em>code page</em>, such as <a href="https://en.wikipedia.org/wiki/Code_page_850">Code Page 850</a>, but this is not enforced and aside from some characters failing to render correctly on the screen, is invisible from an application point of view.</p>
<p>Ordinarily the OS will maintain a cursor position and any text written to the Console will be added to the screen at that position. The screen has a nominal width and height, and when the cursor gets to the end of a line it moves down to the start of the next line. The console will also handle the following special characters in the usual way:</p>
<table><thead><tr><th>ASCII Code</th><th>C Escape Sequence</th><th>Keypress</th><th>Name</th><th>Function</th></tr></thead><tbody>
<tr><td>0x07</td><td><code>\a</code></td><td>Ctrl+H</td><td>Bell</td><td>Produces a beep from the speaker</td></tr>
<tr><td>0x08</td><td><code>\b</code></td><td>Ctrl+H</td><td>Backspace</td><td>Move to one character to the left</td></tr>
<tr><td>0x09</td><td><code>\t</code></td><td>Ctrl+I</td><td>Tab</td><td>Move to next column which is a multiple of 8</td></tr>
<tr><td>0x0A</td><td><code>\n</code></td><td>Ctrl+J</td><td>Line Feed</td><td>Move to start of next line</td></tr>
<tr><td>0x0C</td><td><code>\f</code></td><td>Ctrl+L</td><td>Form Feed</td><td>Clear the screen and move to start of first line</td></tr>
<tr><td>0x0D</td><td><code>\r</code></td><td>Ctrl+M</td><td>Carriage Return</td><td>Move to start of current line</td></tr>
</tbody></table>
<p>For some text mode applications, more precise control is required over the position of the cursor, the colour of the text, and so on. This is acheived by inserting <em>ANSI Escape Sequences</em> into the octet stream. The sequences supported are a subset of those defined in <a href="https://www.ecma-international.org/publications/files/ECMA-ST/Ecma-048.pdf">ECMA-48</a>, and broadly align with those commonly used on Linux/UNIX systems, although support for the specific colours, etc, depends on the video support available in the BIOS. In the following table:</p>
<ul>
<li><code>ESC</code> means <em>Escape</em>. It is represented by the single Unicode character <code>U+001B</code> (<code>0x1B</code> in UTF-8).</li>
<li><code>CSI</code> means <em>Control Sequence Introducer</em>. It is represented by the the single Unicode character <code>U+009B</code> (or <code>0xC2 0x9B</code> in UTF-8), or alternatively the two character sequence <code>ESC [</code> (<code>0x1B 0x5B</code> in UTF-8).</li>
<li>The lowercase characters <em>n</em> and <em>m</em> represent optional integer parameters, rendered as decimal in ASCII using the characters <code>0</code> to <code>9</code>.</li>
<li>Rows and Columns are 1 indexed, with <code>1,1</code> being the top left of the screen.</li>
</ul>
<table><thead><tr><th>Sequence</th><th>Function</th></tr></thead><tbody>
<tr><td>ESC c</td><td>Reset to Intial State</td></tr>
<tr><td>CSI <em>n</em> A</td><td>Cursor Up <em>n</em> (default 1) rows</td></tr>
<tr><td>CSI <em>n</em> B</td><td>Cursor Down <em>n</em> (default 1) rows</td></tr>
<tr><td>CSI <em>n</em> C</td><td>Cursor Forward <em>n</em> (default 1) columns</td></tr>
<tr><td>CSI <em>n</em> D</td><td>Cursor Back <em>n</em> (default 1) columns</td></tr>
<tr><td>CSI <em>n</em> ; <em>m</em> H</td><td>Cursor Position to row <em>n</em> (default 1) and column <em>m</em> (default 1)</td></tr>
<tr><td>CSI <em>n</em> [ ; <em>m</em> ] m</td><td><em>Select Graphic Rendition</em> (see below for valid parameters)</td></tr>
</tbody></table>
<p>The <em>Select Graphic Rendition</em> codes are as follows. Note that multiple codes can be specified in one escape sequence, separated by semicolons. Most of the codes only affect text which is subsequently printed to the console - the only exception is the font select commands 10 to 13 which change the font for the entire screen. The loading of custom fonts is performed through a separate OS call.</p>
<table><thead><tr><th>SGR Code</th><th>Function</th></tr></thead><tbody>
<tr><td>0</td><td>All attributes off</td></tr>
<tr><td>1</td><td>Subsequent text is bold</td></tr>
<tr><td>8</td><td>Subsequent text is concealed (replaced with *)</td></tr>
<tr><td>4</td><td>Subsequent text is underlined</td></tr>
<tr><td>7</td><td>Swap foreground/background colours</td></tr>
<tr><td>10</td><td>Select default font (usually VGA Code Page 850)</td></tr>
<tr><td>11</td><td>Select alternative font 1 (usually Teletext)</td></tr>
<tr><td>12</td><td>Select alternative font 2 (user defined)</td></tr>
<tr><td>13</td><td>Select alternative font 3 (user defined)</td></tr>
<tr><td>28</td><td>Turns off conceal mode</td></tr>
<tr><td>30</td><td>Set foreground colour to Black</td></tr>
<tr><td>31</td><td>Set foreground colour to Red</td></tr>
<tr><td>32</td><td>Set foreground colour to Green</td></tr>
<tr><td>33</td><td>Set foreground colour to Yellow</td></tr>
<tr><td>34</td><td>Set foreground colour to Blue</td></tr>
<tr><td>35</td><td>Set foreground colour to Magenta</td></tr>
<tr><td>36</td><td>Set foreground colour to Cyan</td></tr>
<tr><td>37</td><td>Set foreground colour to White</td></tr>
<tr><td>40</td><td>Set background colour to Black</td></tr>
<tr><td>41</td><td>Set background colour to Red</td></tr>
<tr><td>42</td><td>Set background colour to Green</td></tr>
<tr><td>43</td><td>Set background colour to Yellow</td></tr>
<tr><td>44</td><td>Set background colour to Blue</td></tr>
<tr><td>45</td><td>Set background colour to Magenta</td></tr>
<tr><td>46</td><td>Set background colour to Cyan</td></tr>
<tr><td>47</td><td>Set background colour to White</td></tr>
</tbody></table>
<p>The Neotron application library allows access to the console via two means:</p>
<ul>
<li>Implicitly, through the use of the <code>println!</code> macro.</li>
<li>Explicitly, through the use of the Standard Output file handle, obtained with <code>neotron::io::stdout()</code> or by opening the <code>CON$:</code> device for writing.</li>
</ul>
<p>The Neotron OS doesn't have a concept of 'Standard Error' as distinct from 'Standard Output'. Application libraries may wish to emulate this feature by, for example, printing any text output by <code>eprintln!</code> in a different colour.</p>
<h3><a class="header" href="#reading-from-con" id="reading-from-con">Reading from <code>CON$:</code></a></h3>
<p>Performing a read on the console device will block the application until either the Enter key is pressed on the keyboard, or <code>Control + C</code> is pressed on the keyboard. If the Enter key is pressed, the UTF-8 encoding of the characters entered by the user are copied to the given buffer (up to as many as will fit). If too many characters are entered to fit in to the given buffer, the Console will beep and the user must use Backspace to remove some characters and free up some buffer space. Characters being entered are echoed to the console (although Conceal mode will help if the user is entering a password).</p>
<p>In the background during this function, the OS is polling the keyboard for key events, handling special keys (like Backspace, or Shift) and when a valid key is pressed, the matching Unicode character is UTF-8 encoded and added to the buffer.</p>
<p>On some Neotron systems, pressing the 'Up' arrow key will restore the previous command line contents (like when using the <code>readline</code> library on GNU/UNIX systems).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neotron::fs::File;
let mut buffer = [0u8; 16];
/// The standard Neotron file read functions can be used to read from the console.
let mut console = File::open(&quot;CON$:&quot;)
	.expect(&quot;Failed to open console for reading&quot;);
match console.read(&amp;mut buffer) {
	Ok(0) =&gt; {
		println!(&quot;You entered an empty string&quot;);
	}
	Ok(n) =&gt; {
		// The Neotron OS guarantees this will be valid UTF-8
		let read_string = unsafe {
			core::str::from_utf8_unchecked(&amp;buffer[0..n])
		};
		println!(&quot;You entered {:?}&quot;, read_string);
	}
	Err(e) =&gt; {
		eprintln!(&quot;Oh, I got read error {:?} reading from the console&quot;, e);
	}
}
/// There is also a Neotron Application Library helper function which reads to a buffer (unlike the normal Rust Standard Library function which reads to a `String`).
let bytes_read = neotron::io::stdin()
	.read_line(&amp;mut buffer)
	.expect(&quot;Failed to read from console&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#reading-from-kbd" id="reading-from-kbd">Reading from <code>KBD$:</code></a></h3>
<p>For some applications, such as games, the application will need raw key up/down events rather than the Unicode characters those key events correspond to. For this, there is a device which returns raw key events. Reading from this device is non-blocking. Mapping is performed if the current keyboard layout is non-QWERTY (e.g. the top left letter key on an AZERTY keyboard is <code>Key::LetterA</code> not <code>Key::LetterQ</code>), but you must perform your own handling of shifted characters (for example how Shift + <code>.</code> gives you a <code>&gt;</code> character when using a United Kingdom keyboard layout). The easiest way to handle this is to allow users to map their own keys (e.g. &quot;Press the key you want to use for 'Jump': &quot;).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Key {
	LetterA,
	LetterB,
	LetterC,
	LetterD,
	...
	Digit0,
	Digit1,
	...
	Dot,
	Comma,
	PrintScreen,
	Up,
	Down,
	Left,
	Right,
	Home,
	End,
	Delete,
	...
}

struct KeyEvent(u8);

impl KeyEvent {
	unsafe fn from_octet(u8) -&gt; KeyEvent;
	fn is_keydown(&amp;self) -&gt; bool;
	fn is_keyup(&amp;self) -&gt; bool;
	fn get_key(&amp;self) -&gt; Key;
}

use neotron::fs::File;
let mut kb = File::open(&quot;KBD$:&quot;).expect(&quot;Failed to open raw keyboard&quot;);
let buffer = [0u8; 16];
/// The standard file read function is used to read from the keyboard
match kb.read(&amp;mut buffer) {
	Ok(0) =&gt; {
		println!(&quot;No raw key events available&quot;);
	}
	Ok(n) =&gt; {
		for octet in buffer[0..n].iter() {
			let ev = unsafe { KeyEvent::from_octet(octet) };
			println!(&quot;Received event {:?}&quot;, ev);
		}
	}
	Err(e) =&gt; {
		eprintln!(&quot;Oh, I got read error {:?} reading from the keyboard&quot;, e);
	}
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#writing-to-kbd" id="writing-to-kbd">Writing to <code>KBD$:</code></a></h3>
<p>The least significant (1) bit of any byte written to KBD$ sets the <em>Num Lock</em> light. The next (2) bit of any byte written to KBD$ sets the <em>Caps Lock</em> light. The next (4) bit of any byte sets the <em>Scroll Lock</em> light. This is useful if you are using raw keyboard mode to handle key events and want to perform your own Num Lock, Caps Lock and Scroll Lock handling.</p>
<h3><a class="header" href="#writing-to-time" id="writing-to-time">Writing to <code>TIME$:</code></a></h3>
<p>Write an ASCII string in ISO-8601 format (e.g. <code>2020-01-01T15:44:21.031Z</code>) to set the time.</p>
<h3><a class="header" href="#reading-from-time" id="reading-from-time">Reading from <code>TIME$:</code></a></h3>
<p>Reading from this device will return an ASCII/UTF-8 string in ISO-8601 format (e.g. <code>2020-01-01T15:44:21.031Z</code>).</p>
<pre><code class="language-console"># Reading the time in the Neotron Shell with the cat command
$ cat TIME$:
2020-01-01T15:44:21.031Z
$
</code></pre>
<h3><a class="header" href="#writing-to-gfx" id="writing-to-gfx">Writing to <code>GFX$:</code></a></h3>
<p>Opening the <code>GFX$mode=X:</code> device puts the system into specified video mode <em>X</em> and gives access to the underlying video RAM. Optional <em>x</em>, <em>y</em>, <em>width</em> and <em>height</em> parameters allow a window to be created into video RAM, which is useful if you want to update a small region. Setting pixels on the screen is simply a case of seeking to the correct position and writing out as many bytes as required. The specific format of the bytes written to this device will depend on the current video mode. There is some other (TBD) mechanism obtain the list of supported video modes and their formats, but they will include Chunky modes (where multiple consecutive bits/bytes map to Red, Green and Blue components for each pixel) and Planar modes (where Red, Green and Blue each have their own distinct regions). This device is useful to blitting bitmaps to the screen, but drawing lines and circles is more efficiently performed through other OS APIs.</p>
<pre><code class="language-console"># Using the copy command in the Neotron Shell to put a picture at the top of the screen in Mode 7
$ copy 0:/EXAMPLE.GFX GFX$mode=7;height=150:
30000 bytes copied
$
</code></pre>
<h3><a class="header" href="#reading-from-gfx" id="reading-from-gfx">Reading from <code>GFX$:</code></a></h3>
<p>Reading from this device allows an application to determine what is currently on the screen. The data is in the same format as when <a href="os.html#writing-to-gfx">writing to the device</a>.</p>
<h3><a class="header" href="#writing-to-prnx" id="writing-to-prnx">Writing to <code>PRNx$:</code></a></h3>
<p>Ordinarily, every byte written to this device is sent to the Parallel Port, followed by high pulse on the <code>STROBE</code> pin and a busy-wait for the <code>BUSY</code> pin to return low. If any error signals are activated by the printer, the write is ended early.</p>
<p>Opening this device with the option <code>raw</code>, enables raw mode. In this mode, each write must be a two byte value:</p>
<ul>
<li>Byte 0 is 0x00 to write to the data pins or 0x01 to write to the control pins</li>
<li>Byte 1 is the value to write to all eight data pins, or to the control pins as per the following table.</li>
</ul>
<table><thead><tr><th>Bit Number</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>1 to enable STROBE (active high)</td></tr>
<tr><td>1</td><td>1 to enable LINE_FEED (active low)</td></tr>
<tr><td>2</td><td>1 to enable RESET (active high)</td></tr>
<tr><td>3</td><td>1 to enable SELECT_PRINTER (active low)</td></tr>
</tbody></table>
<p>In <code>raw</code> mode you can use the Parallel Port as a generic GPIO port with 12 output pins, and 5 <a href="os.html#reading-from-prn">input pins</a>.</p>
<h3><a class="header" href="#reading-from-prnx" id="reading-from-prnx">Reading from <code>PRNx$:</code></a></h3>
<p>A read will return one byte which is a bitmask of the status bits, regardless of whether it was opened in raw mode or normal mode.</p>
<table><thead><tr><th>Bit Number</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>1 when ERROR is active (low)</td></tr>
<tr><td>1</td><td>1 when SELECT_IN is active (high)</td></tr>
<tr><td>2</td><td>1 when PAPER_OUT is active (high)</td></tr>
<tr><td>3</td><td>1 when ACK is active (low)</td></tr>
<tr><td>4</td><td>1 when BUSY is active (low)</td></tr>
</tbody></table>
<h3><a class="header" href="#writing-to-discx" id="writing-to-discx">Writing to <code>DISCx$:</code></a></h3>
<p>Allows access to the raw blocks on a disk. Useful for writing out disk images. Support for creating partition tables is TBD, and may have to be done at the application level by writing to the first sector on disk. Writing to raw disk structures whilst files are open on that volume is likely to lead to filesystem corruption.</p>
<h3><a class="header" href="#reading-from-discx" id="reading-from-discx">Reading from <code>DISCx$:</code></a></h3>
<p>Allows access to the raw blocks on a disk. Useful for taking disk images, or inspecting raw disk structures. The option <code>partition=X</code> allows a specific partition to be selected, where <code>1</code> to <code>4</code> are the first four Primary partitions, and <code>5</code> or greater selects a Logical Partition located within the Extended Partition. Inspecting the partition metadata (start, end, filesystem type, etc) must be done at the application level by reading the first sector.</p>
<h3><a class="header" href="#opening-serx" id="opening-serx">Opening 'SERx$:'</a></h3>
<table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>handshaking=rtscts</td><td>Enable RTS/CTS handshaking</td></tr>
<tr><td>handshaking=xonoff</td><td>Enable XON/XOFF handshaking</td></tr>
<tr><td>handshaking=none</td><td>Disable handshaking (default)</td></tr>
<tr><td>bps=X</td><td>Set bitrate to X bits per second</td></tr>
<tr><td>timeout=X</td><td>Set read/write timeout to X frames</td></tr>
<tr><td>timeout=none</td><td>Block forever on read/write</td></tr>
<tr><td>timeout=0</td><td>Never block on read/write</td></tr>
</tbody></table>
<h3><a class="header" href="#writing-to-serx" id="writing-to-serx">Writing to <code>SERx$:</code></a></h3>
<p>A write will block until all of the octets have been transmitted to the remote device at the specified bit rate, or a timeout occurs (if specified).</p>
<h3><a class="header" href="#reading-from-serx" id="reading-from-serx">Reading from <code>SERx$:</code></a></h3>
<p>A read will block until the given number of octets have been received from the remote device at the specified bit rate, or a timeout occurs (if specified).</p>
<h3><a class="header" href="#opening-tonex" id="opening-tonex">Opening 'TONEx$:'</a></h3>
<p>No options when opening TONE devices.</p>
<h3><a class="header" href="#writing-to-tonex" id="writing-to-tonex">Writing to <code>TONEx$:</code></a></h3>
<p>A tone is specified with three parameters:</p>
<ul>
<li>A frequency, in Hertz.</li>
<li>A waveform (e.g. Square, Sine, Triangle, White Noise, etc)</li>
<li>A volume (between 1 and 16)</li>
</ul>
<p>These three parameters are packed into four bytes:</p>
<pre><code> Byte 0        Byte 1        Byte 2        Byte 3
+-------------+-------------+-------------+-------------+
|Frequency LSB|Frequency MSB|Waveform     |Volume       |
+-------------+-------------+-------------+-------------+
</code></pre>
<p>The buffer written must be a multiple of four octets in length.</p>
<h3><a class="header" href="#reading-from-tonex" id="reading-from-tonex">Reading from <code>TONEx$:</code></a></h3>
<p>Not supported.</p>
<h3><a class="header" href="#opening-pcmx" id="opening-pcmx">Opening 'PCMx$:'</a></h3>
<table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>channels=N</td><td>Enable <em>N</em> channels (default is 1)</td></tr>
<tr><td>bits=U8</td><td>Set 8-bit linear unsigned samples</td></tr>
<tr><td>bits=S8</td><td>Set 8-bit linear signed samples</td></tr>
<tr><td>bits=U16</td><td>Set 16-bit linear unsigned samples</td></tr>
<tr><td>bits=S16</td><td>Set 16-bit linear signed samples</td></tr>
<tr><td>rate=X</td><td>Configure for X samples per second</td></tr>
</tbody></table>
<h3><a class="header" href="#writing-to-pcmx" id="writing-to-pcmx">Writing to <code>PCMx$:</code></a></h3>
<p>When the PCM device is opened, the number of channels (mono/stereo), sample rate (e.g. 22,050 Hz), bit depth (e.g. 8 bits) are specified. The bytes written are the samples to be played, as little-endian integers. If there are multiple channels, the samples for each channel are supplied in turn before moving on to the next sample (e.g. <em>Left Sample N</em>, <em>Right Sample N</em>, <em>Left Sample N+1</em>, <em>Right Sample N+1</em>). You should write sufficiently often to avoid underflowing the internal PCM buffer.</p>
<h3><a class="header" href="#reading-from-pcmx" id="reading-from-pcmx">Reading from <code>PCMx$:</code></a></h3>
<p>When the PCM device is opened, the number of channels (mono/stereo), sample rate (e.g. 22,050 Hz), bit depth (e.g. 8 bits) are specified. The bytes read are the samples which have been recorded, as little-endian integers. If there are multiple channels, the samples for each channel are supplied in turn before moving on to the next sample (e.g. <em>Left Sample N</em>, <em>Right Sample N</em>, <em>Left Sample N+1</em>, <em>Right Sample N+1</em>). You should read sufficiently often to avoid overflowing the internal PCM buffer.</p>
<h3><a class="header" href="#writing-to-jsx" id="writing-to-jsx">Writing to <code>JSx$:</code></a></h3>
<p>Not supported</p>
<h3><a class="header" href="#reading-from-jsx" id="reading-from-jsx">Reading from <code>JSx$:</code></a></h3>
<p>Returns a bitmask of inputs from that joystick:</p>
<table><thead><tr><th>Bit Number</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>Up</td></tr>
<tr><td>1</td><td>Down</td></tr>
<tr><td>2</td><td>Left</td></tr>
<tr><td>3</td><td>Right</td></tr>
<tr><td>4</td><td>Fire 1 (B)</td></tr>
<tr><td>5</td><td>Fire 2 (C)</td></tr>
<tr><td>6</td><td>Fire 3 (A)</td></tr>
<tr><td>7</td><td>Fire 4 (Start)</td></tr>
</tbody></table>
<p>Yes, the fire buttons are in that order - mainly because on a Master System pad, you only have Fire Button 1 and Fire Button 2, but on a Mega Drive pad, those same pins on the interface correspond to Fire Buttons B and C. If you have a standard Atari/Commodore joystick, you will probably only have Fire Button 1.</p>
<p>The OS will poll the joystick once per video frame, so attempting to read more often than that will given repeated results. A fire button is very likely to be held for multiple frames, so you will need to store the previous reading and check which bits have flipped since last time.</p>
<h2><a class="header" href="#threads-and-processes" id="threads-and-processes">Threads and Processes</a></h2>
<p>The Neotron OS has no support for running multiple processes, nor for multi-threading, nor for multi-core systems. It is very much like MS-DOS and CP/M in this regard. It does, however, use locks to ensure that should the use of interrupts cause a function to be 're-entered', the situation is caught gracefully rather than leading to system instability. A user is, therefore, free to implement multi-threading within their application if they so wish.</p>
<h2><a class="header" href="#memory-allocation" id="memory-allocation">Memory Allocation</a></h2>
<p>The Neotron BIOS initialise all of the RAM, configures a stack, reserves a further portion of RAM for its own use, and passes the OS a structure which describes the start and end address of each contiguous block of remaining memory (and there may be several if your CPU has multiple separate SRAMs). From this remainder, the Neotron OS allocates what it needs for its own purposes.</p>
<p>The Neotron OS has a built-in heap memory allocation routine (like <code>malloc</code>) and matching deallocation routine (like <code>free</code>) and it offers these to the currently running application. This saves the application having to include its own memory allocation routines. When an application is loaded, the heap is automatically set to use all of the remaining un-used RAM (which varies depending on the size of the application). Applications are usually (but not always) given the same stack as the OS and the BIOS, and so it is very possible for a badly behaved application to corrupt and/or crash the entire system.</p>
<p>An application can always assume its own RAM for code and global variables starts at address <code>0x2000_0000</code>. The memory allocation routines may return an address from some other range (e.g. the AXI SRAM on an STM32H7 is at 0x2400_0000).</p>
<h2><a class="header" href="#networking" id="networking">Networking</a></h2>
<p>The TCP/IP stack offers a Berkley Sockets style API. Supported devices will include an SPI based Ethernet MAC/PHY devices (such as the Microchip ENC28J60) using <a href="https://github.com/m-labs/smoltcp">smoltcp</a>, and UART based Ethernet/WiFi/Cellular devices with on-board TCP/IP stack (such as the ESP-01).</p>
<h1><a class="header" href="#the-neotron-command-shell" id="the-neotron-command-shell">The Neotron Command Shell</a></h1>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p>The Neotron Shell is the first application started by the OS. It allows the user to give the system commands, including:</p>
<ul>
<li>Browsing filesystems on the SD card</li>
<li>Loading files from SD card into RAM</li>
<li>Inspecting the contents of RAM and ROM</li>
<li>Executing applications</li>
</ul>
<p>The Shell uses the standard OS API and hence is much like a normal application. The only difference is that it uses a special region of memory, allowing it to remaining running whilst it loads another application into the main program area. Once that application is started, it can use the shell's memory region as it's own - the OS will re-initialise the shell when the application exits.</p>
<p>Analogies from the PC world would include MS-DOS's <code>COMMAND.COM</code> and CP/M's CCP, but at a functional level it's more like the U-Boot Shell.</p>
<h2><a class="header" href="#shell-expansion" id="shell-expansion">Shell Expansion</a></h2>
<p>Any argument of the form <code>${VAR}</code> is replaced with the value stored in the environment variable called <code>VAR</code>.</p>
<p>Any argument containing a <code>*</code> character is taken to be a glob and is expanded to all the filenames matching that glob. Note that there are a limited number of arguments that can be given to a command, so attempts to glob more files than that number will generate an error.</p>
<h2><a class="header" href="#magic-devices" id="magic-devices">Magic Devices</a></h2>
<p>The OS supports a number of magic device filenames. The shell is unaware of this and just asks the OS to perform the specified operation on the given filenames.</p>
<h2><a class="header" href="#shell-commands" id="shell-commands">Shell Commands</a></h2>
<h3><a class="header" href="#dir" id="dir">DIR</a></h3>
<p>Performs a directory listing, either for the current drive and directory or of the given absolute or relative path.</p>
<h3><a class="header" href="#mkdir" id="mkdir">MKDIR</a></h3>
<p>Creates a new directory, given either an absolute path or a relative path.</p>
<h3><a class="header" href="#type" id="type">TYPE</a></h3>
<p>Displays the contents of a file, assuming it is ASCII text.</p>
<h3><a class="header" href="#hexdump" id="hexdump">HEXDUMP</a></h3>
<p>Displays the contents of a file as hex encoded binary.</p>
<h3><a class="header" href="#copy" id="copy">COPY</a></h3>
<p>Copies a file from one location to another.</p>
<h3><a class="header" href="#rename" id="rename">RENAME</a></h3>
<p>Changes the name of a file.</p>
<h3><a class="header" href="#move" id="move">MOVE</a></h3>
<p>Moves a file from one directory to another.</p>
<h3><a class="header" href="#del" id="del">DEL</a></h3>
<p>Deletes a file.</p>
<h3><a class="header" href="#rmdir" id="rmdir">RMDIR</a></h3>
<p>Deletes an empty folder.</p>
<h3><a class="header" href="#deltree" id="deltree">DELTREE</a></h3>
<p>Recursively deletes a folder.</p>
<h3><a class="header" href="#peek" id="peek">PEEK</a></h3>
<p>Displays the contents of ROM or RAM at the given address.</p>
<h3><a class="header" href="#poke" id="poke">POKE</a></h3>
<p>Writes a new value to RAM at the given address. Attempts to write to ROM are ignored.</p>
<h3><a class="header" href="#save" id="save">SAVE</a></h3>
<p>Copies RAM or ROM to a file on disk.</p>
<h3><a class="header" href="#load" id="load">LOAD</a></h3>
<p>Copies the contents of a file on disk to RAM.</p>
<h3><a class="header" href="#exec" id="exec">EXEC</a></h3>
<p>Performs a LOAD of the given file, followed by a RUN. This command is implied if a command is given which matches the name of a file in the current directory, or in the system PATH.</p>
<h3><a class="header" href="#run" id="run">RUN</a></h3>
<p>Runs a program in memory.</p>
<h3><a class="header" href="#set" id="set">SET</a></h3>
<p>Sets an environment variable to the given value.</p>
<h3><a class="header" href="#echo" id="echo">ECHO</a></h3>
<p>Prints some text to the console.</p>
<h3><a class="header" href="#loadenv" id="loadenv">LOADENV</a></h3>
<p>Loads environment variables from a file.</p>
<h3><a class="header" href="#saveenv" id="saveenv">SAVEENV</a></h3>
<p>Saves environment variables to a file.</p>
<h3><a class="header" href="#script" id="script">SCRIPT</a></h3>
<p>Runs the shell commands found in the given filename.</p>
<h3><a class="header" href="#edit" id="edit">EDIT</a></h3>
<p>Starts a full-screen ASCII file editor.</p>
<h3><a class="header" href="#dev" id="dev">DEV</a></h3>
<p>Shows the list of devices reported by the BIOS.</p>
<h3><a class="header" href="#vol" id="vol">VOL</a></h3>
<p>Shows the current list of volumes, by drive. Includes their volume names, format and storage capacity.</p>
<h3><a class="header" href="#scan" id="scan">SCAN</a></h3>
<p>Re-scans the given device for volumes. Volumes which are no longer present (e.g. because the disk has been removed) are de-allocated their volume ID. New volumes are allocated new volume IDs.</p>
<h3><a class="header" href="#cd" id="cd">CD</a></h3>
<p>Change the current directory. May include a volume ID, or be relative to the current volume, or the current folder. Unlike MS-DOS, there is only one current directory for the whole system (instead of one for each drive).</p>
<h3><a class="header" href="#attr" id="attr">ATTR</a></h3>
<p>Gets or sets a file's attributes (Read Only, Archive, System and Hidden).</p>
<h1><a class="header" href="#the-neotron-menu-shell" id="the-neotron-menu-shell">The Neotron Menu Shell</a></h1>
<p>In some cases, the Neotron Command Shell is a little <em>too</em> bare-bones. Perhaps the primary use of the Neotron is to play some games, or perhaps you want to browse the SD quickly using a GUI. For these situations, you can set your default shell to be the Menu Shell.</p>
<p>The Menu Shell is inspired by the boot-up menu on NextOS for the <a href="https://www.specnext.com/">Spectrum Next</a>.</p>
<p><img src="./system_next_menu.jpg" alt="The Spectrum Next NextOS boot menu" /></p>
<p>The Neotron Menu is displayed in text-mode (nominally 48x36) and offers a series of options the user can scroll between using the arrow keys on a PS/2 keyboard or a Joystick in Port 1. These options all correspond to an item in the Neotron Command Shell, and so there is no extra functionality offered by the Neotron Menu Shell - it just makes existing functionality easier to access. Note that the final item on the list exits the Neotron Menu Shell and replaces it as the current shell with the Neotron Command Shell.</p>
<ul>
<li>File Manager - allows the user to browse the list of volumes, and the files and directories on those volumes. It supports the usual Create/Move/Rename/Copy/Load/Delete operations.</li>
<li>Tiny BASIC - loads <a href="https://en.wikipedia.org/wiki/Tiny_BASIC">Tiny BASIC</a> compiled as Neotron Application.</li>
<li>6502 BASIC - loads a 6502 Emulator, which then runs Enhanced BASIC.</li>
<li>Test Video - runs through the various graphical/text video modes.</li>
<li>Test Audio - runs through the various tones that can be generated.</li>
<li>Test Parallel Port - displays the printer status, and optionally sends some ASCII text to the parallel printer port.</li>
<li>Configure Date/Time - displays the current RTC status and allows the date/time to be set.</li>
<li>Configure Keyboard - allows the keyboard to be tested, and the layout selected </li>
<li>MIDI Keyboard - allows you to use the Neotron as a synthesiser, by connecting a MIDI Keyboard to the MIDI In port.</li>
<li>Configure WiFi - allows you to browse the WiFi networks, and join a particular network.</li>
<li>Serial Terminal - allows you to exchange characters with any serial port in the system, including the RS-232 port and the WiFi interface.</li>
</ul>
<h1><a class="header" href="#neotron-applications" id="neotron-applications">Neotron Applications</a></h1>
<p>Neotron Applications are loaded into RAM and then executed. For portability, they should use the API provided by the OS, but the system implements no security features or memory-protection, so once they are running, they have complete control of the entire system.</p>
<p>Existing applications include:</p>
<ul>
<li>A text-mode Snake game</li>
<li>A 6502 emulator which runs 6502 Enhanced BASIC</li>
<li>Tiny BASIC</li>
<li>A slideshow/presentation tool</li>
<li>A simple synthesiser which plays notes according to MIDI input</li>
</ul>
<h1><a class="header" href="#neotron-hardware" id="neotron-hardware">Neotron Hardware</a></h1>
<p>The Netron OS is intended to be binary-portable across any machine with a Neotron BIOS. How that works out in practice remains to be seen, but that's the goal. As the BIOS API, example BIOS implementations and the OS itself are entirely open, anyone can build their own Neotron-compatible system, using any ARMv7-M compatible processor.</p>
<h2><a class="header" href="#example-systems" id="example-systems">Example systems</a></h2>
<p>To demonstrate the practicality of making a portable OS for ARMv7-M, we are in the process of producing a number of Neotron compatible systems. Note that some (or all) of these may never be completed, but all in-progress designs remain available under an open-licence.</p>
<ul>
<li><a href="./7_1_neotron32.html">Neotron 32</a> - an open-source PCB which plugs into the Texas Instruments TM4C Launchpad (a derivative of the original Montron project).</li>
<li><a href="./7_2_neotron340st.html">Neotron 340ST</a> - based on an STM32F7-DISCOVERY PCB; not open-source hardware, but easily available from ST and it comes with schematics.</li>
<li><a href="./7_3_neotron500.html">Neotron 500</a> - an unfinished attempt an an open-source PCB using an STM32H7 and other parts from the JLCPCB catalog so it could be built using their assembly service.</li>
<li><a href="./7_4_neotron600.html">Neotron 600</a> - an open-source PCB which plugs into the Teensy 4.1.</li>
<li><a href="./7_5_neotron1000.html">Neotron 1000</a> - an open-source PCB based around the STM32H7, along with a Lattice iCE40 FPGA for hardware accelerated video output.</li>
<li><a href="./7_6_neotron9X.html">Neotron 9X</a> - an open-source PCB based around the Microchip SAM9X60D5M system-in-package. Possibly not a &quot;Neotron&quot; as not a Cortex-M chip.</li>
</ul>
<h2><a class="header" href="#form-factor" id="form-factor">Form Factor</a></h2>
<p>The original Monotron didn't have a particular form-factor - the PCB was simply made large enough to accept all the desired connectors. The Neotron 32 was upsized slightly to fit the Hammond 1598C series case, however, there were issues that meant a full-size SD card did not fit. The work-around was to use a microSD card, but all available examples proved difficult to hand-solder. An upgrade to the larger Hammond 1598D was investigated, but expansion options for the system still remained limited.</p>
<p>One of the nice features of the IBM PC (and its clones), and also the Apple II series, was the provision of expansion slots. These allowed extra functionality to be added at a later date - often well beyond what the original designer had envisaged at the time the main system was developed. Whilst the Hammond cases work well as a small desktop, they do lack the space for expansion cards - at least, expansion cards with their own connectors.</p>
<p>The alternative would be to produce a board based around the ATX standard - either full-size ATX (305x244mm), micro-ATX (244x244mm), or micro-ITX (170x170mm). These boards would include some crucial components (e.g. audio codec, VGA DAC, power supply), but move much of the other functionality off onto expansion cards (MIDI, Parallel Port, Joystick Ports, etc). Rather than use ISA-style card-edge connectors (which require the expansion card to have a harder gold finish which can survive the plugging-unplugging), we're considering using standard IDC headers. These would, however, be located such that the expansion cards would line up with standard ATX case expansion slot holes.</p>
<p>Unfortunately, being quite a large board means it can be quite expensive to produce. We also note that many of our target CPUs are only supplied in BGA package, which means four layers at a minimum, and the decoupling capacitors have to be fitted to the reverse of the board. This seems to place a high-bar on self-assembly at home - requiring basically a full surface-mount rework station. Instead, it seemed to make sense to locate the complex components on a carrier card (CPU, SDRAM, etc) and leave the main board to carry the through-hole connectors and simpler, lower pin-count, parts like the audio codec.</p>
<p>There are a number of standards we could use for the interface to the processor card:</p>
<ul>
<li><a href="https://learn.adafruit.com/adafruit-feather/feather-specification">Feather</a>: Lots of GPIO (including I²C and SPI) but no defined interface for video, and not specific set of pins assigned for I²S.</li>
<li><a href="https://www.mikroe.com/mikrobus">MikroBus</a>: Designed for expansion cards, rather than processor cards. But our expansion connectors will carry broadly similar sets of pins.</li>
<li><a href="https://download.mikroe.com/flyers/mcu-card-flyer-web.pdf">Mikro MCU Card</a>: Carries almost all of the connections we'd like to get off a SoC (including the all-important RGB LCD interface we need for VGA output). The only downside is the use of two high density 168-pin headers which look pretty tricky to solder, and cost about £4.50 each. </li>
<li>[Raspberry Pi CM1/CM3]: This pinout is quite specific to the BCM2835 and BCM2837 SoCs used, and includes HDMI, Display Serial Interface and Camera Serial Interface. It does support USB and parallel RGB though. </li>
<li>[Raspberry Pi CM4]: This pinout is quite specific to the BCM2711, and if parallel RGB is used, there are no other GPIO pins available. Uses two 100-pin high-density headers.</li>
</ul>
<p>In the end, it's probably easier to come up with our own standard to suit our specific requirements. The signals we need include:</p>
<ul>
<li>Parallel RGB video (22)
<ul>
<li>18-bit RGB</li>
<li>H-Sync</li>
<li>V-Sync</li>
<li>DDC SDA</li>
<li>DDC SCL</li>
</ul>
</li>
<li>2x USB 2.0 Host @ 480 Mbps (4)
<ul>
<li>Port 0 D+</li>
<li>Port 0 D-</li>
<li>Port 1 D+</li>
<li>Port 1 D-</li>
</ul>
</li>
<li>Console UART @ 115,200 bps (4)
<ul>
<li>TX</li>
<li>RX</li>
<li>RTS</li>
<li>CTS</li>
</ul>
</li>
<li>2x PS/2 Interface (4)
<ul>
<li>Port 1 DAT</li>
<li>Port 1 CLK</li>
<li>Port 2 DAT</li>
<li>Port 2 CLK</li>
</ul>
</li>
<li>I²S Codec (5)
<ul>
<li>DAC Data</li>
<li>DAC Left/Right Clock</li>
<li>ADC Data</li>
<li>ADC Left/Right Clock</li>
<li>Bit Clock</li>
</ul>
</li>
<li>I²C @ 400 kHz (2)
<ul>
<li>SDA</li>
<li>SCL</li>
</ul>
</li>
<li>Control (10)
<ul>
<li>/Reset</li>
<li>/Enable</li>
<li>IRQ x8</li>
</ul>
</li>
<li>Power (6)
<ul>
<li>2x 5.0V @ 2A max, combined</li>
<li>2x 3.3V @ 200mA max, combined</li>
<li>4x GND</li>
</ul>
</li>
<li>SPI @ 25 MHz (11)
<ul>
<li>COPI</li>
<li>CIPO</li>
<li>CLK</li>
<li>CS x8</li>
</ul>
</li>
<li>SD/MMC (6)
<ul>
<li>DAT0</li>
<li>DAT1</li>
<li>DAT2</li>
<li>DAT3</li>
<li>CMD</li>
<li>CLK</li>
</ul>
</li>
</ul>
<p>This requires at least 74 pins, ideally more as we probably want to include more Ground pins around the high-speed signals. There is a risk that despite this, sending high speed signals (USB 2.0 High-Speed, 40MHz+ parallel RGB) will cause significant EMC issues.</p>
<p>We could include the VGA DAC on the MCU card, reducing the VGA pins from 22 (18x digital RGB + 4) to 7 (3x analog video + 4), but that would then preclude the use of a parallel-RGB to DVI/HDMI encoder at a later date.</p>
<p>If we stick with simple 0.1&quot; pitch pins (easy to solder), one option is two 2xN headers, like the Launchpad uses.</p>
<pre><code>o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
</code></pre>
<p>This has 80 pins, and occupies 51mm by 31mm. As you can see it would produce quite a long CPU card, and seems to waste the space between the two headers. It is, however, the approach taken by the <a href="https://www.waveshare.com/coreh743i.htm">Waveshare CoreH743I board</a> used by the <a href="https://geoffg.net/CMM2_Description.html">Colour Maximite 2</a>.</p>
<p>We could also try a double-square arrangement:</p>
<pre><code>o o o o o o o o o o o o
o o o o o o o o o o o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o o o o o o o o o o o
o o o o o o o o o o o o
</code></pre>
<p>This has (11 + 9) * 4 = 80 pins, and occupies around 31mm x 31mm, with a central area of 20mm x 20mm to fit the SoC and all the decoupling capacitors. Of course, the general shape can be scaled up if required - the Intel 80386 had a 132-pin PGA package laid out as follows:</p>
<pre><code>o o o o o o o o o o o o o o
o o o o o o o o o o o o o o
o o o o o o o o o o o o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o o o o o o o o o o o o
o o o o o o o o o o o o o o
o o o o o o o o o o o o o o
</code></pre>
<h2><a class="header" href="#future-models" id="future-models">Future Models</a></h2>
<p>When it comes to picking an SoC for a new Neotron model, the following are important criteria:</p>
<ul>
<li>Uses an ARMv7E-M compatible core (i.e. Cortex-M4, Cortex-M7 or Cortex-M33)</li>
<li>Can generate digital RGB video at 40 MHz (800x600) or some integer fraction
<ul>
<li>Anything between 3-bits and 24-bits per pixel is acceptable.</li>
<li>Ideally would also support the VGA standard 640x480@60 and 640x400@70 25.175 MHz modes as well</li>
</ul>
</li>
<li>Has a four-wire UART for a backup console</li>
<li>Has at least 256 KiB of memory for BIOS / OS (Flash or RAM) </li>
<li>Has enough RAM to support the desired video modes (800x600, 8bpp needs around 470 KiB)</li>
<li>Has at least 64 KiB of free application RAM (ideally 256 KiB or more)</li>
<li>Has at least one USB 2.0 Host port
<ul>
<li>Ideally supports High-Speed without an external PHY</li>
</ul>
</li>
<li>Has an SPI Controller interface which can run at 25 MHz, along with 8 chip-select and 8 interrupt GPIO lines</li>
<li>Has an I²C Controller interface which can run at 400 kHz</li>
<li>Has an I²S audio codec interface, or can generate analog audio</li>
<li>Has a ROM bootloader which can boot from UART, USB or SD Card
<ul>
<li>This is so home-made systems do not require an ARM debug probe for initial programming</li>
</ul>
</li>
<li>Is possible to manually solder to a simple 4-layer PCB without micro-vias, i.e. one of
<ul>
<li>0.8mm+ pitch ball grid array (BGA) package</li>
<li>0.5mm+ pitch quad flip-chip (QFP) package</li>
</ul>
</li>
<li>Has 3.3V I/O</li>
<li>Ideally takes a 3.3V power rail which is internally regulated
<ul>
<li>Where multiple rails are required, we either need relaxed requirements in sequencing, or an available PMIC chip which brings the rails up in the right order</li>
</ul>
</li>
<li>Cost under $20 in one-off quantities</li>
<li>Available from mainstream catalog vendors (e.g. Digikey)
<ul>
<li>Ideally also available from the JLCPCB Parts Catalog</li>
</ul>
</li>
</ul>
<p>We've identified the following parts as meeting some or more of the above criteria:</p>
<table><thead><tr><th align="left">Manuf.</th><th align="left">Part Number</th><th align="left">Core</th><th align="left">Clock</th><th align="left">Package</th><th align="left">RAM (KiB)</th><th align="left">Flash (KiB)</th><th align="left">Price</th><th align="left">Notes</th></tr></thead><tbody>
<tr><td align="left">ST</td><td align="left">STM32H730ZBT6</td><td align="left">Cortex-M7</td><td align="left">550 MHz</td><td align="left">LQFP 144</td><td align="left">564</td><td align="left">128</td><td align="left">£5.87</td><td align="left">Great value due to small Flash.</td></tr>
<tr><td align="left">NXP</td><td align="left">IMXRT1062DVJ6A</td><td align="left">Cortex-M7</td><td align="left">600 MHz</td><td align="left">BGA 196</td><td align="left">1024</td><td align="left">0</td><td align="left">£8.70</td><td align="left">As used on Teensy 4.1</td></tr>
<tr><td align="left">ST</td><td align="left">STM32H743ZGT6</td><td align="left">Cortex-M7</td><td align="left">480 MHz</td><td align="left">LQFP 144</td><td align="left">1024</td><td align="left">1024</td><td align="left">£9.38</td><td align="left">Cheapest 1 MiB H7</td></tr>
<tr><td align="left">ST</td><td align="left">STM32H7A3ZIT6</td><td align="left">Cortex-M7</td><td align="left">280 MHz</td><td align="left">LQFP 144</td><td align="left">1344</td><td align="left">2048</td><td align="left">£10.35</td><td align="left">Big SRAM - might not need external RAM?</td></tr>
<tr><td align="left">TI</td><td align="left">TM4C1299KCZADI3</td><td align="left">Cortex-M4</td><td align="left">120 MHz</td><td align="left">VFBGA 212</td><td align="left">256</td><td align="left">512</td><td align="left">£12.78</td><td align="left">Poor value, but same family as Neotron-32</td></tr>
</tbody></table>
<p>It is worth also considering the Lattice range of small, low-cost FPGAs, and loading an RISC-V soft-core like the VexRiscv.</p>
<h1><a class="header" href="#neotron-32" id="neotron-32">Neotron 32</a></h1>
<p>The Neotron 32 is the baby of the Neotron range. As the name suggests, it has just 32 KiB of SRAM (along with 256 KiB of Flash ROM). It is based around a Texas Instruments Launchpad board, and uses the same basic design as the earlier Monotron project.</p>
<h2><a class="header" href="#links" id="links">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-32-Hardware">https://github.com/Neotron-Compute/Neotron-32-Hardware</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-32-BIOS">https://github.com/Neotron-Compute/Neotron-32-BIOS</a></li>
<li>Main CPU Board: <a href="https://www.ti.com/tool/EK-TM4C123GXL">https://www.ti.com/tool/EK-TM4C123GXL</a></li>
</ul>
<h2><a class="header" href="#features" id="features">Features</a></h2>
<p>The full specifications are:</p>
<ul>
<li><strong>CPU:</strong> Texas Instruments TM4C123 SoC, on a Texas Instruments Tiva-C Launchpad PCB
<ul>
<li><strong>Processor Core</strong>: 80 MHz ARM Cortex-M4F</li>
<li><strong>RAM:</strong> 32 KiB on-die SRAM</li>
<li><strong>ROM:</strong> 256 KiB on-die Flash</li>
<li><strong>GPU:</strong> None - software VGA using 3x SPI interfaces
<ul>
<li>800x600 nominal resolution</li>
<li>400x300 effective resolution</li>
<li>48-column colour text mode and 80-column mono text mode</li>
<li>Maximum 8 colours</li>
</ul>
</li>
</ul>
</li>
<li><strong>Video Output:</strong> SVGA
<ul>
<li>Nominally 800x600 at 60 Hz</li>
<li>Simple 330 ohm terminated video output</li>
</ul>
</li>
<li><strong>Storage:</strong> SD Card slot, supports FAT16/FAT32 and MS-DOS partition tables</li>
<li><strong>USB:</strong> 1x internal USB 2.0 Full-speed micro-AB port</li>
<li><strong>Audio:</strong> 37 kHz PWM audio with three channel wavetable synthesiser
<ul>
<li>3.5mm stereo Line Out</li>
</ul>
</li>
<li><strong>Keyboard/Mouse:</strong> 2x PS/2 Ports (2x 6-pin mini-DIN)</li>
<li><strong>MIDI</strong>: MIDI In and MIDI Out (2x 5-pin 180-degree DIN)</li>
<li><strong>Serial</strong>: RS-232 on 10-pin 2.54mm header suitable for DE-9 plug on IDC ribbon</li>
<li><strong>Parallel</strong>: 3.3v PC-style Parallel Port with DB-25 port
<ul>
<li>Also functions as 3.3v GPIO with 12 outputs and 4 inputs.</li>
</ul>
</li>
<li><strong>Joystick</strong>: 2x 9-pin game ports
<ul>
<li>supports Atari-compatible two-button joysticks, or SEGA MegaDrive/Genesis controllers</li>
</ul>
</li>
<li><strong>Expansion</strong>: 2x internal 2.54mm 2x6 headers carrying power, SPI, I2C and a dedicated IRQ line</li>
<li><strong>RTC</strong>: MCP7940N and coin-cell battery backup</li>
<li><strong>Mechanical Form Factor:</strong> Fits Hammond [1598D] case</li>
</ul>
<p>The Cortex-M4 is responsible for generating the video pixels, at a rate of 40 million mono pixels/second (in high-res text mode) or 20 million colour pixels/second (in all other modes). This leaves only around 4.5% of the CPU available (during the vertical blanking interval) to run your application, which brings the performance down to around the same as a 2 MHz 6502. This is enough to run simple games or a BASIC interpreter. The challenge is to see how much you can squeeze out of such limited resources!</p>
<p>The Neotron 32 uses a Texas Instruments Launchpad board to provide the processing power. This is fitted to a custom PCB which breaks out all of the ports, and adds an AtMega AVR CPU to control the PS/2 and Joystick interfaces. The PCB design is <a href="https://certification.oshwa.org/uk000007.html">registered open-source hardware</a>, and <a href="https://github.com/neotron-compute/neotron-32-hardware">available on Github</a>. The <a href="https://github.com/neotron-compute/neotron-32-bios">ROM BIOS</a> and <a href="https://github.com/neotron-compute/neotron-os">Neotron OS</a> are also fully open-source and available on Github. The ROM BIOS and OS are loaded over the Launchpad's USB debug connection using standard TI Tiva-C flashing tools (such as OpenOCD, or lm4flash). Once flashed, applications can be loaded from a FAT32 formatted SD card.</p>
<h2><a class="header" href="#architecture" id="architecture">Architecture</a></h2>
<p>In a typical 8-bit home computer, the main processor was just a CPU, and all the other peripherals (GPIO ports, RAM, video, etc) were external devices that sat on the processor's address and data bus. On the Neotron 32, the Texas Instruments TM4C123 SoC integrates all of those features (well, not video, but we work around that by misusing some of the serial peripherals) into a single package. The main external interfaces from the SoC are narrow serial buses such as SPI, I²C and UART rather than the wide 8-bit data bus and 16-bit address bus of an 8-bit home computer. The I²C bus is ideal for low-bandwidth peripherals, such as real-time clocks, whilst the SPI bus can be driven at up to 20 MHz, giving 20 Mbit/sec (or around 2400 KiB/sec) making it better for mass storage and networking.</p>
<p>On current revisions of the Neotron 32, the I/O controller (responsible for the PS/2 interfaces and the two Joystick ports) is connected to the main SoC via a UART link. It is likely, however, that this will change to be an I²C based device with an interrupt line in future, following the standard Microsoft HID over I²C Protocol.</p>
<pre><code>+-----------------+
|                 |
|     TM4C123     |
|                 |
+-----------------+
   |   |  | | | |
   |   |  | | | +---&lt;UART&gt; Neotron I/O Controller
   |   |  | | +---&lt;UART&gt; Wi-Fi Modem
   |   |  | +---&lt;UART&gt; RS-232 Interface
   |   |  +---&lt;UART&gt; MIDI In/Out
   |   |
   | &lt;I2C&gt;
   |   |
   |   +-- Real-Time Clock
   |   +-- Neotron I/O Controller (future possibility)
   |   +-- Expansion Port A
   |   +-- Expansion Port B
   |
 &lt;SPI&gt;
   |
   +--- SD Card
   +--- GPIO Port / Parallel Port
   +--- Expansion Port A
   +--- Expansion Port B
</code></pre>
<h1><a class="header" href="#video" id="video">Video</a></h1>
<p>Video is generated on the Neotron-32 by driving three SPI interfaces in a synchronised fashion - one generating a stream of red pixels, one a stream of green pixels and one a stream of green pixels. There is also a Horizontal Sync line driven from a Timer, which is synchronised to the pixel outputs, and a Vertical Sync line which is a GPIO line driven in the Horizontal Scan-line Interrupt Handler.</p>
<p>With a CPU clock of 80 MHz, the SPI ports can be run at either 40 MHz or 20 MHz. 40 MHz generates an 800x600 pixel image with a 60 Hz refresh rate, and 20 MHz generates a 400x600 pixel image with a 60 Hz refresh rate. To counter the 'stretch' effect of the latter mode, we only generate 300 lines of video and clock each out one twice, giving an effective 400x300 resolution.</p>
<p>The hardware on the motherboard simply consists of some resistors which, in conjunction with the 75 ohm input impedance of a VGA monitor, drops the 3.3V signal from the SoC down to the 0.7V maximum given in the VGA standard. With the three channels (R, G and B) being either on or off, we get 8 familiar colour combinations:</p>
<ul>
<li>Black</li>
<li>Red</li>
<li>Green</li>
<li>Yellow</li>
<li>Blue</li>
<li>Magenta</li>
<li>Cyan</li>
<li>White</li>
</ul>
<p>As the SoC can only just push out the 8 mA required to drive a VGA signal into 75 ohms, later Neotron systems are likely to use a small active VGA/RGB video filter to act as a line driver.</p>
<h1><a class="header" href="#audio" id="audio">Audio</a></h1>
<p>The Neotron 32 generates mono pulse-width-modulated (PWM) audio with 8-bit centre-aligned pulses at a frequency of four times the horizontal video scan rate (giving roughly 151,500 samples per second). At the end of each scan-line, a new 8-bit PCM sample is generated by summing the outputs of three basic wavetable synthesisers. That PCM sample is fed to the PWM hardware at the start of the next scan line (to reduce jitter) and it gets played out four times during that scan line, giving an effective sample rate of just under 38 kHz. The hardware then consists of a simple low-pass filter to remove the PWM carrier frequency, and a headphone jack. As the SoC can't drive a large amount of current, amplified speakers are required.</p>
<p>Each of the three channels on the wavetable synthesiser can produce a square, sawtooth or sine waveforms, or random noise, at a selected frequency. There is also a rudimentary volume control for each channel.</p>
<h1><a class="header" href="#sdmmc" id="sdmmc">SDMMC</a></h1>
<p>The SD Card Slot takes microSD cards (frustratingly, full size SD card slots don't really fit on the front edge with the Joystick ports, because of the placement of the PCB/case screw holes). These are connected up using the <em>SPI Compatibility</em> mode built into all SD and SDHC memory cards. No interrupt line is required - the SD card responds only when polled and gives out repeated <code>0xFF</code> bytes when busy completing an operation.</p>
<h1><a class="header" href="#ps2" id="ps2">PS/2</a></h1>
<p>The Neotron I/O controller is responsible for the PS/2 interfaces and the two Joystick ports. It consists of an AtMega 328 microcontroller with custom firmware, and speaks a bespoke <em>HID over UART</em> protocol. The Joystick ports can be either standard Atari joysticks, or SEGA MegaDrive / Genesis 3-button pads. With some software work, 6-button pads could possibly also be supported.</p>
<p>In the future, we may change this to speak <em>HID over I²C</em> to reduce the number of UARTs required.</p>
<p>Currently the AtMega firmware is written in C++. As Rust on AVR matures we may look to a Rust implementation to allow us to share code with the BIOS.</p>
<h1><a class="header" href="#wifi" id="wifi">WiFi</a></h1>
<p>The Espressif ESP-01 is a Wi-Fi Modem based on the Espressif ESP8266 Wi-Fi chipset. It has an on-board TCP/IP stack, and speaks AT commands. To the Neotron 32 SoC, it basically appears as a classic RS-232 Hayes-compatible AT modem.</p>
<h1><a class="header" href="#expansion" id="expansion">Expansion</a></h1>
<h1><a class="header" href="#parallel-port" id="parallel-port">Parallel Port</a></h1>
<p>The MCP23S17 I/O Expander sits on the SPI bus, with a dedicated IRQ line. This can be used to drive a PC-style 25-pin Parallel Printer Port, or it can be used as a general-purpose 16-bit GPIO interface. Running at up to 10 MHz, all 16-bits can be written to in 4 bytes, which takes 32 microseconds or 256 clock cycles. As the Parallel Port strobe pin is driven separately from an SoC GPIO line, and with the MCP23S17 able to generate an Interrupt when the remote device raises the ACK line, this interface should be sufficient for around 150 KiB/sec.</p>
<h1><a class="header" href="#rs-232" id="rs-232">RS-232</a></h1>
<p>A four-wire (<code>TX</code>, <code>RX</code>, <code>RTS</code>, <code>CTS</code>) RS-232 interface is provided via a 10-pin 0.1&quot; boxed header. These headers are used on old ISA Serial Port expansion cards for when the 9-pin D-Sub (<em>DE9</em>, not <em>DB9</em>) receptacle didn't fit on the edge of the card and had to be moved to a second bracket, one slot over.</p>
<p>The <code>DTR</code>, <code>DSR</code>, <code>DCD</code> and <code>RI</code> pins are not connected.</p>
<h1><a class="header" href="#midi" id="midi">MIDI</a></h1>
<p>MIDI is basically an opto-isolated UART based protocol running at a fixed 31,250 bps. The MIDI In port is connected to UART RX via an opto-isolator, and the MIDI Out port is driven from UART TX via a 5V level shifter (two back-to-back inverters from a hex-inverter).</p>
<h1><a class="header" href="#usb" id="usb">USB</a></h1>
<p>The TM4C Launchpad used in the Neotron 32 has a full-speed (11 Mbps) USB On-The-Go peripheral routed to a USB micro-AB port. This means it is normally a USB Device (e.g. a USB Serial Adaptor, or a USB Human Interface Device), but it can be placed into a mode where it acts as a USB Host. To make this work, we need two things:</p>
<ol>
<li>A USB micro-AB to USB Type-A Receptacle adaptor.</li>
</ol>
<ul>
<li>These adaptors are commonly used with the USB micro-AB ports on a Raspberry Pi.</li>
<li>We could optionally plug in a USB Hub if we wanted to connect more than one USB Device.</li>
</ul>
<ol start="2">
<li>A USB Host stack.</li>
</ol>
<p>The part latter is going to be difficult - the USB protocol intentionally places the burden of work on the Host developer, because that end of the link generally costs more, and has more power available. We have a couple of options available:</p>
<ol>
<li>Use the Texas Instruments Tiva-C <em>usblib</em> stack (https://github.com/yuvadm/stellaris/tree/master/usblib).</li>
<li>Use the USB Host stack from Das U-Boot, or some similar project.</li>
<li>Write a USB Host stack from scratch in Rust.</li>
</ol>
<p>All of these options are out-of-scope for the time being.</p>
<h1><a class="header" href="#rtc" id="rtc">RTC</a></h1>
<p>The TM4C SoC has a battery-backed real-time clock function, but the TM4C Launchpad doesn't break out the battery backup pin and so it will always forget the time when the system is powered off.</p>
<p>Instead, an MCP7940N battery-backed real-time clock chip keeps track of calendar time when the system is powered off, and also offers 64 bytes of battery backed SRAM for system settings. Like on an IBM PC-compatible, removing the battery will &quot;reset&quot; the system settings (on a PC this is known as <em>clearing the CMOS</em>, for various historical reasons).</p>
<h1><a class="header" href="#neotron-340st" id="neotron-340st">Neotron 340ST</a></h1>
<p>The Neotron 340ST is based on the ST 32F746G-DISCOVERY. This is an off-the-shelf evaluation-kit aimed at the hobbyist market featuring an STM32F7 SoC, a colour LCD display, audio output jack and expansion headers. It is not open-source hardware, but it is easily available from ST and it comes with schematics.</p>
<h2><a class="header" href="#links-1" id="links-1">Links</a></h2>
<ul>
<li>Hardware: <a href="https://www.st.com/en/evaluation-tools/32f746gdiscovery.html">https://www.st.com/en/evaluation-tools/32f746gdiscovery.html</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-340ST-BIOS">https://github.com/Neotron-Compute/Neotron-340ST-BIOS</a></li>
<li>Main CPU: <a href="https://www.st.com/content/st_com/en/products/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus/stm32-high-performance-mcus/stm32f7-series/stm32f7x6/stm32f746ng.html">https://www.st.com/content/st_com/en/products/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus/stm32-high-performance-mcus/stm32f7-series/stm32f7x6/stm32f746ng.html</a></li>
</ul>
<h2><a class="header" href="#features-1" id="features-1">Features</a></h2>
<ul>
<li>216 MHz 32-bit ARM Cortex-M7 CPU core</li>
<li>320 KiB of on-chip SRAM</li>
<li>8 MiB 16-bit SDRAM</li>
<li>16 MiB QuadSPI Flash</li>
<li>480x272 colour TFT LCD</li>
<li>Cirrus WM8994ECS Audio codec with:
<ul>
<li>Stereo line output</li>
<li>Stereo speaker output</li>
<li>Stereo line input</li>
<li>S/PDIF input</li>
<li>Stereo on-board microphones</li>
</ul>
</li>
<li>One high-speed (480 Mbps) USB 2.0 OTG (AB) port in Host mode</li>
<li>One full-speed (12 Mbps) USB 2.0 OTG (AB) port in Host mode</li>
<li>microSD Slot</li>
<li>10/100 Ethernet Port</li>
<li>DCMI digital camera input</li>
<li>Arduino headers (3.3V)</li>
<li>On-board ST-Link/V2-1 programmer/debugger, with USB Serial interface</li>
<li>7-12V DC barrel jack for power input</li>
</ul>
<h1><a class="header" href="#neotron-500" id="neotron-500">Neotron 500</a></h1>
<p>The Neotron 500 is an unfinished attempt an an open-source PCB using an STM32H7. The idea was to only use parts from the JLCPCB catalog so that it could be built using their low-cost surface-mount PCB Assembly service. Unfortunately, it transpires that the STM32H7's QuadSPI controller only supports Flash ROM, not SRAM, meaning to get the targeted 8 MiB of RAM, a DDR SDRAM chip would be required. Currently that appears to be more difficult to lay out, and so the project was abandoned in favour of the Neotron 600.</p>
<p>It should also be noted that almsot all STM32 F7 and H7 series parts currently do not include a High-Speed USB2.0 PHY, instead requiring an external ULPI PHY. There are some very new parts which do include a USB2.0 High-Speed PHY, but they don't include a TFT controller.</p>
<h2><a class="header" href="#links-2" id="links-2">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-500-Hardware">https://github.com/Neotron-Compute/Neotron-500-Hardware</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-500-BIOS">https://github.com/Neotron-Compute/Neotron-500-BIOS</a></li>
<li>Main CPU: <a href="https://www.st.com/en/microcontrollers-microprocessors/stm32h743ii.html">https://www.st.com/en/microcontrollers-microprocessors/stm32h743ii.html</a></li>
</ul>
<h2><a class="header" href="#features-2" id="features-2">Features</a></h2>
<ul>
<li>480 MHz 32-bit ARM Cortex-M7 CPU core</li>
<li>1024 KiB of internal ECC SRAM</li>
<li>8 MiB external DRAM</li>
<li>Super-VGA output
<ul>
<li>640x480</li>
<li>800x600</li>
<li>256 colours from a pallette of 262,144</li>
</ul>
</li>
<li>16-bit 48 kHz audio input and output (line-in, mic-in, line-out and headphone-out)</li>
<li>Four high-speed (480 Mbps) USB 2.0 ports
<ul>
<li>Two USB A ports on-board</li>
<li>Header for additional two ports</li>
</ul>
</li>
<li>IEEE-1284 Parallel Port</li>
<li>RS232 Port (five-wire)</li>
<li>SD/MMC Slot</li>
<li>PS/2 Keyboard and Mouse ports</li>
<li>2x Atari/Sega joystick ports</li>
<li>Battery-backed Real-time Clock and CMOS RAM</li>
<li>SPI and I2C based expansion bus</li>
</ul>
<h1><a class="header" href="#neotron-600" id="neotron-600">Neotron 600</a></h1>
<p>The Neotron 600 is an open-source PCB which plugs into the Teensy 4.1. Using the Teensy 4.1 gives it excellent performance, an Ethernet PHY and a support for an easy-to-fit external QuadSPI SRAM chip. The only downside is that the pinout limits the colour output to 7 bits (128 colours).</p>
<h2><a class="header" href="#links-3" id="links-3">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-600-Hardware">https://github.com/Neotron-Compute/Neotron-600-Hardware</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-600-BIOS">https://github.com/Neotron-Compute/Neotron-600-BIOS</a></li>
<li>Main CPU: <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/i-mx-rt-crossover-mcus/i-mx-rt1060-crossover-mcu-with-arm-cortex-m7-core:i.MX-RT1060">https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/i-mx-rt-crossover-mcus/i-mx-rt1060-crossover-mcu-with-arm-cortex-m7-core:i.MX-RT1060</a></li>
</ul>
<h2><a class="header" href="#features-3" id="features-3">Features</a></h2>
<ul>
<li><strong>Processor Module</strong>: Teensy 4.1
<ul>
<li><strong>CPU:</strong> NXP i.MX RT1062 SoC
<ul>
<li><strong>Core</strong>: 600 MHz Cortex-M7</li>
<li><strong>RAM:</strong> 1024 KiB FlexRAM</li>
<li><strong>ROM:</strong> 128 KiB Boot ROM (factory programmed mask ROM)</li>
<li><strong>GPU:</strong> NXP i.MXRT LCD Controller
<ul>
<li>1366x768 maximum resolution</li>
<li>Supports bitblit, rotation, alpha, chroma-key</li>
</ul>
</li>
</ul>
</li>
<li>8 MiB Flash</li>
<li>8 MiB QuadSPI SRAM (optional)</li>
<li>10/100 Ethernet PHY</li>
</ul>
</li>
<li><strong>Video Output:</strong> SVGA
<ul>
<li>Nominally 800x600 at 60 Hz</li>
<li>Other resolutions TBD (depends on pixel clock)</li>
<li>Texas Instruments THS7316 Video Amplifier used to drive 75 ohm VGA output</li>
<li>2x 2-bit + 1x 3-bit 0.1% R2R DACs, to give max 128 (2^7) colours</li>
</ul>
</li>
<li><strong>Storage:</strong> SD Card slot, supports FAT16/FAT32 and MS-DOS partition tables</li>
<li><strong>USB:</strong> 2x external USB 2.0 Full-speed Type-A Host ports (with a header for two more)</li>
<li><strong>Audio:</strong> 16-bit 48 kHz stereo
<ul>
<li>Wolfson WM8731 Audio CODEC</li>
<li>3.5mm stereo Line Out</li>
<li>3.5mm stereo Amplified headphone output</li>
<li>Digital volume control</li>
</ul>
</li>
<li><strong>Keyboard/Mouse:</strong> 2x PS/2 Ports (2x 6-pin mini-DIN)</li>
<li><strong>Serial</strong>: RS-232 on 10-pin 2.54mm header suitable for DE-9 plug on IDC ribbon, MAX3232 transceiver</li>
<li><strong>Ethernet</strong>: Standard 100base-TX RJ45 port (driven from PHY on Teensy 4.1)</li>
<li><strong>Expansion</strong>: 4x internal 2.54mm 2x6 headers carrying power, SPI, I2C and a dedicated IRQ line</li>
<li><strong>RTC</strong>: MCP7940N RTC and coin-cell battery backup</li>
<li><strong>Mechanical Form Factor:</strong> microATX</li>
</ul>
<h1><a class="header" href="#neotron-1000" id="neotron-1000">Neotron 1000</a></h1>
<p>The Neotron 1000 is the full-fat, top-of-the-line Neotron, packed into the same form factor as a Raspberry Pi 4. It has an STM32H7 driving one video output, and a Lattice Semi iCE40 FPGA driving a second video output - both via HDMI encoders.</p>
<h2><a class="header" href="#features-4" id="features-4">Features</a></h2>
<ul>
<li><strong>CPU</strong>: STMicroelectronics H7 Series CPU 400MHz</li>
<li><strong>Memory</strong>: 8MB DRAM</li>
<li><strong>GPU</strong>: Lattice ICE40 Series Soft Core (Hardware Accelerated Rendering)</li>
<li><strong>GPU RAM</strong>: 16MB SRAM</li>
<li><strong>Storage</strong>: SD Card Slot</li>
<li><strong>Network</strong>: 10Base-T Ethernet</li>
<li><strong>USB</strong>: 2x USB2 High speed host ports</li>
<li><strong>Audio</strong>: Line Out / In Combo Jack</li>
<li><strong>Video</strong>: Dual HDMI (1 CPU, 1 GPU)</li>
<li><strong>Other IO</strong>: PS2 Keyboard/Mouse Port, Pi compatible Hat Connector (40 pin)</li>
<li><strong>Mechanical Form Factor</strong>: Raspberry Pi 4B</li>
</ul>
<h1><a class="header" href="#neotron-9x" id="neotron-9x">Neotron 9X</a></h1>
<p>If the Neotron 32 is like a BBC Micro, the Neotron 9X is like an Acorn RISC PC. It uses the Microchip SAM9X system-in-package, which bundles DDR SDRAM alongside the SoC in the same package. This hugely simplifies PCB routing as compared to the Neotron 500.</p>
<p>As it runs an ARM9 core and has 64 MiB of DDR2 SDRAM, it would run RISC OS, or even Linux quite happily. In future, we may develop a RISC OS or Windows 95 like shell which sits above the Neotron OS. Performance wise, this system is broadly similar to a mid-1990s Pentium 200 MMX.</p>
<p>Because the ARM9 will not run Cortex-M3/4/7 (i.e. ARMv7-M or ARMv7E-M) machine code, it is incompatible with standard Neotron applications, and they will need to be recompiled for the ARM9 (i.e. ARMv5TE architecture). You could make an argument, therefore, that the Neotron 9X isn't a Neotron at all.</p>
<h2><a class="header" href="#links-4" id="links-4">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-9X-Hardware">https://github.com/Neotron-Compute/Neotron-9X-Hardware</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-9X-BIOS">https://github.com/Neotron-Compute/Neotron-9X-BIOS</a></li>
<li>Main CPU: <a href="https://www.microchip.com/wwwproducts/en/SAM9X60D5M">https://www.microchip.com/wwwproducts/en/SAM9X60D5M</a></li>
</ul>
<h2><a class="header" href="#features-5" id="features-5">Features</a></h2>
<ul>
<li><strong>CPU:</strong> Microchip SAM9X60D5M System-in-Package
<ul>
<li><strong>Processor Core</strong>: 600 MHz ARM926EJ-S
<ul>
<li>32 KiB Instruction Cache</li>
<li>32 KiB Data Cache</li>
<li>Memory Management Unit</li>
</ul>
</li>
<li><strong>RAM:</strong> 64 MiB on-package DDR2
<ul>
<li>Also has 64 KiB on-die SRAM</li>
</ul>
</li>
<li><strong>ROM:</strong> 256 KiB Serial Flash
<ul>
<li>Can load BIOS from &quot;boot.bin&quot; on SD-Card, like an Amiga 1000 loads Kickstart from floppy disk</li>
<li>Can also load BIOS into RAM from Serial Flash</li>
</ul>
</li>
<li><strong>GPU:</strong> Microchip SAM9 LCD Controller
<ul>
<li>800x600 resolution (chip supports up to 1024x768 resolution maximum)</li>
<li>Typically 16 or 256 colour pallete mode to save Video RAM</li>
<li>Optional 16-bit mode for improved colour depth</li>
<li>Three hardware overlays with transparency</li>
<li>Hardware scaling</li>
</ul>
</li>
<li><strong>GPU RAM:</strong> Shared with main SDRAM</li>
</ul>
</li>
<li><strong>Video Output:</strong> SVGA
<ul>
<li>Nominally 800x600 at 60 Hz</li>
<li>Other resolutions TBD (pixel clock is limited to integer divisors of system clock)</li>
<li>Texas Instruments THS7316 Video Amplifier used to drive 75 ohm VGA output</li>
<li>Triple 6-bit 0.1% R2R DACs, to give max 262,144 (2^18) colours</li>
</ul>
</li>
<li><strong>Storage:</strong> SD Card slot, supports FAT16/FAT32 and MS-DOS partition tables</li>
<li><strong>USB:</strong> 2x external USB 2.0 Full-speed Type-A Host ports (with a header for one more)</li>
<li><strong>Audio:</strong> 16-bit 48 kHz stereo
<ul>
<li>Wolfson WM8731 Audio CODEC</li>
<li>3.5mm stereo Line Out</li>
<li>3.5mm stereo Amplified headphone output</li>
<li>Digital volume control</li>
</ul>
</li>
<li><strong>Keyboard/Mouse:</strong> 2x PS/2 Ports (2x 6-pin mini-DIN)</li>
<li><strong>Serial</strong>: RS-232 on 10-pin 2.54mm header suitable for DE-9 plug on IDC ribbon</li>
<li><strong>Ethernet</strong>: Standard 100base-TX RJ45 port.</li>
<li><strong>Expansion</strong>: 4x internal 2.54mm 2x6 headers carrying power, SPI, I2C and a dedicated IRQ line</li>
<li><strong>RTC</strong>: Coin-cell battery backup for the main CPU's RTC.</li>
<li><strong>Mechanical Form Factor:</strong> microATX</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
